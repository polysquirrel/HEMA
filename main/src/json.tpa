ACTION_IF NOT VARIABLE_IS_SET JSON4WEIDU THEN BEGIN
OUTER_TEXT_SPRINT JSON4WEIDU ~JSON4WEIDU~ 

//INCLUDE ~stringutil.tpa~
INCLUDE ~%MOD_FOLDER%/stringutil.tpa~

OUTER_TEXT_SPRINT JSON_PROPERTY_SEPARATOR ~.~


/** Regexp matching any sequence of '\' terminated by a character other than '"' and '\', 
  * or an odd sequence of '\' terminated by '"'. */
OUTER_TEXT_SPRINT JSON_STRING_ATOM_RX ~\(\\*[^\"]\|\([^\]\\\(\\\\\)*"\)\)~
/** Any string surrounded by a pair of '"' characters, in which all '"' are escaped with a '\'.*/
OUTER_TEXT_SPRINT JSON_STRING_RX ~"\(\(\\\(\\\\\)*"\)?\(%JSON_STRING_ATOM_RX%*\)\(\(\\\\\)*\)\)"~ 

OUTER_TEXT_SPRINT JSON_NULL ~null~

OUTER_SET MAX_INT = BIT31 - 1
 



 
  
DEFINE_ACTION_MACRO trim_json_front BEGIN
	LAF trim_string_front STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END



DEFINE_PATCH_MACRO trim_json_front BEGIN
	LPF trim_string_front STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END



DEFINE_ACTION_MACRO trim_json_back BEGIN
	LAF trim_string_back STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END



DEFINE_PATCH_MACRO trim_json_back BEGIN
	LPF trim_string_back STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END



DEFINE_ACTION_MACRO trim_json BEGIN
	LAF trim_string STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END



DEFINE_PATCH_MACRO trim_json BEGIN
	LPF trim_string STR_VAR string = EVALUATE_BUFFER ~%json%~ RET json = res END
END
 





DEFINE_ACTION_FUNCTION json_escape_str
	STR_VAR	str = ~~
	RET	res 
	BEGIN
		OUTER_PATCH_SAVE res ~%str%~ BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
			REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		END
	END
 
 
 
 DEFINE_PATCH_FUNCTION json_escape_str
	STR_VAR str = ~~
	RET res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_escape_str STR_VAR str = EVALUATE_BUFFER ~%str%~ RET res END
		END
	END
	
 
 
 DEFINE_ACTION_FUNCTION json_unescape_str
	STR_VAR json = ~~
	RET	res 
	BEGIN
		OUTER_PATCH_SAVE res ~%json%~ BEGIN
			REPLACE_EVALUATE CASE_SENSITIVE ~\\\(.\)~ BEGIN 
				PATCH_IF ~%MATCH1%~ STR_EQ ~\~ THEN BEGIN
					TEXT_SPRINT replacement ~\\~
				END ELSE BEGIN
					TEXT_SPRINT replacement ~%MATCH1%~
				END
			END ~%replacement%~
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_unescape_str
	STR_VAR json = ~~
	RET res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_unescape_str STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
		END
	END


	
	
	

DEFINE_ACTION_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		ACTION_IF boolean THEN BEGIN
			OUTER_TEXT_SPRINT res ~true~
		END ELSE BEGIN
			OUTER_TEXT_SPRINT res ~false~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		PATCH_IF boolean THEN BEGIN
			TEXT_SPRINT res ~true~
		END ELSE BEGIN
			TEXT_SPRINT res ~false~
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		OUTER_TEXT_SPRINT res ~%number%~
	END
	
	

DEFINE_PATCH_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		TEXT_SPRINT res ~%number%~
	END
	
	
	
DEFINE_ACTION_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN 
		LAF json_escape_str STR_VAR str = EVALUATE_BUFFER ~%string%~ RET res END
		//OUTER_PATCH_SAVE res ~%string%~ BEGIN
		//	REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
		//	REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		//END
		OUTER_TEXT_SPRINT res ~"%res%"~
	END
	
	
	
DEFINE_PATCH_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_string STR_VAR string = EVALUATE_BUFFER ~%string%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_array
	STR_VAR arrayvar = ~~
	RET res
	BEGIN
		OUTER_SET i = 0
		OUTER_TEXT_SPRINT res ~[~
		ACTION_PHP_EACH ~%arrayvar%~ AS _ => value BEGIN
			ACTION_IF i == 0 THEN BEGIN
				OUTER_TEXT_SPRINT res ~[%value%~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~%res%, %value%~
			END
			OUTER_SET i += 1
		END
		OUTER_TEXT_SPRINT res ~%res%]~
	END
	
	
	
DEFINE_PATCH_FUNCTION json_array
	STR_VAR arrayvar = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array STR_VAR arrayvar = EVALUATE_BUFFER ~%arrayvar%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION array_to_json
	STR_VAR arrayvar = ~~
	RET res
	BEGIN
		OUTER_SET i = 0
		OUTER_TEXT_SPRINT res ~[~
		
		ACTION_PHP_EACH ~%arrayvar%~ AS _ => value BEGIN
			ACTION_IF NOT IS_AN_INT %value% THEN BEGIN
				LAF json_string STR_VAR string = EVALUATE_BUFFER ~%value%~ RET value = res END
			END
			
			ACTION_IF i == 0 THEN BEGIN
				OUTER_TEXT_SPRINT res ~%res%%value%~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~%res%, %value%~
			END
			OUTER_SET i += 1
		END
		OUTER_TEXT_SPRINT res ~%res%]~
	END
	
	
	
DEFINE_PATCH_FUNCTION array_to_json
	STR_VAR arrayvar = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF array_to_json STR_VAR arrayvar = EVALUATE_BUFFER ~%arrayvar%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_object
	STR_VAR dictvar = ~~
	RET res
	BEGIN
		OUTER_TEXT_SPRINT res ~{~
		OUTER_SET i = 0
		
		ACTION_PHP_EACH ~%dictvar%~ AS key => value BEGIN
			LAF json_string STR_VAR string = EVALUATE_BUFFER ~%key%~ RET field = res END
				
			ACTION_IF i == 0 THEN BEGIN
				OUTER_TEXT_SPRINT res ~{%field%: %value%~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~%res%, %field%: %value%~
			END
			OUTER_SET i += 1
		END
		OUTER_TEXT_SPRINT res ~%res%}~

	END



DEFINE_PATCH_FUNCTION json_object
	STR_VAR	dictvar = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_object STR_VAR dictvar = EVALUATE_BUFFER ~%dictvar%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION dict_to_json
	STR_VAR dictvar = ~~
	RET res
	BEGIN
		OUTER_SET i = 0
		OUTER_TEXT_SPRINT res ~{~
		ACTION_PHP_EACH ~%dictvar%~ AS key => value BEGIN
			LAF json_string STR_VAR string = EVALUATE_BUFFER ~%key%~ RET field = res END
			
			ACTION_IF NOT IS_AN_INT %value% THEN BEGIN
				LAF json_string STR_VAR string = EVALUATE_BUFFER ~%value%~ RET value = res END
			END

			ACTION_IF i == 0 THEN BEGIN
				OUTER_TEXT_SPRINT res ~{%field%: %value%~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~%res%, %field%: %value%~
			END
			OUTER_SET i += 1
		END
		OUTER_TEXT_SPRINT res ~%res%}~

	END



DEFINE_PATCH_FUNCTION dict_to_json
	STR_VAR	dictvar = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF dict_to_json STR_VAR dictvar = EVALUATE_BUFFER ~%dictvar%~ RET res END
		END
	END
	
	
	
	

	
DEFINE_ACTION_FUNCTION consume_json_null 
	STR_VAR json = ~~
	RET 
		consumed
		tail
	BEGIN
		LAM trim_json_front
		OUTER_TEXT_SPRINT consumed ~~
		OUTER_TEXT_SPRINT tail ~%json%~
		OUTER_SET length = STRING_LENGTH ~%json%~ 
		ACTION_IF length >= 4 THEN BEGIN
			LAF SUBSTRING 
				INT_VAR start = 0 length = 4 
				STR_VAR string = EVALUATE_BUFFER ~%json%~
				RET consumed END
			ACTION_IF ~%substring%~ STR_EQ ~null~ THEN BEGIN
				LAF SUBSTRING
					INT_VAR start = 4 length = length - 4
					STR_VAR string = EVALUATE_BUFFER ~%json%~
					RET tail = substring END
			END ELSE BEGIN
				OUTER_TEXT_SPRINT consumed ~~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION consume_json_null
	STR_VAR json = ~~
	RET 
		consumed
		tail
	BEGIN
		INNER_ACTION BEGIN
			LAF consume_json_null STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION consume_json_number
	STR_VAR json = ~~
	RET 
		consumed
		tail
	BEGIN
		OUTER_TEXT_SPRINT consumed ~~
		LAM trim_json_front
		LAF string_prefix_length //get the candidate prefix to avoid parsing the whole json
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = ~[-+0-9A-za-z]~
			RET length END
		LAF SUBSTRING 
			INT_VAR start = 0 length = length 
			STR_VAR string = EVALUATE_BUFFER ~%json%~
			RET prefix = substring END
		
		OUTER_PATCH ~%prefix%~ BEGIN
			REPLACE_EVALUATE CASE_SENSITIVE ~^\([-+]?\([0-9A-Za-z]\)+\)\(\|[^0-9A-Za-z].*\)$~ BEGIN
				PATCH_IF IS_AN_INT ~%MATCH1%~ THEN BEGIN
					TEXT_SPRINT consumed ~%MATCH1%~
				END
			END ~~
			PATCH_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN
				TEXT_SPRINT tail ~%json%~
			END ELSE BEGIN
				SET length = STRING_LENGTH ~%consumed%~ 
				LPF SUBSTRING
					INT_VAR start = length length = STRING_LENGTH ~%json%~ - length
					STR_VAR string = EVALUATE_BUFFER ~%json%~
					RET tail = substring END
			END
		END
	END
	
	

DEFINE_ACTION_FUNCTION consume_json_boolean
	STR_VAR json = ~~
	RET
		consumed
		tail
	BEGIN
		OUTER_TEXT_SPRINT consumed ~~
		LAF string_prefix_length 
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET length srclength END

		OUTER_PATCH ~%json%~ BEGIN
			PATCH_IF length + 5 <= srclength THEN BEGIN
				READ_ASCII length consumed (5)
				PATCH_IF ~%consumed%~ STR_EQ ~false~ THEN BEGIN
					READ_ASCII (length + 5) tail (srclength - length - 5)
				END ELSE BEGIN
					TEXT_SPRINT consumed ~~
				END
			END 
			PATCH_IF ~%consumed%~ STR_EQ ~~ AND length + 4 <= srclength THEN BEGIN
				READ_ASCII length consumed (4)
				PATCH_IF ~%consumed%~ STR_EQ ~true~ THEN BEGIN
					READ_ASCII (length + 4) tail (srclength - length - 4)
				END ELSE BEGIN
					TEXT_SPRINT consumed ~~
				END
			END				
		END

		ACTION_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT tail ~%json%~
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION consume_json_string
	STR_VAR json = ~~
	RET
		consumed
		tail
	BEGIN
		OUTER_TEXT_SPRINT consumed ~~		
		LAF string_prefix_length 
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET offset = length length = srclength next END

		ACTION_IF offset < length - 1 AND ~%next%~ STR_EQ ~"~ THEN BEGIN // "" takes two characters
			OUTER_PATCH ~%json%~ BEGIN
				SET i = offset + 1
				TEXT_SPRINT next ~~
				WHILE (i < length AND NOT ~%next%~ STR_EQ ~"~) BEGIN //let's find the closing '"'
					READ_ASCII i next (1)
					SET j = i
					WHILE (j < length - 1 AND ~%next%~ STR_EQ ~\~) BEGIN
						SET j += 1
						READ_ASCII j next (1)
					END
					PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //check if it's escaped
						PATCH_IF (j - i) MODULO 2 == 1 THEN BEGIN //escaped
							SET i = j + 1
							PATCH_IF i == length THEN BEGIN
								TEXT_SPRINT next ~~ //terminate the loop, 'hide' the '"'
							END ELSE BEGIN //skip over '"' before the main loop sees it!
								READ_ASCII i next (1)
								SET i = i + 1
							END
						END ELSE BEGIN //the loop will terminate
							SET i = j
						END
					END ELSE BEGIN //%next% is not '\', so we can safely advance, covering the case i=j
						SET i = j + 1
					END
				END
				PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //yay!
					READ_ASCII offset consumed (j - offset + 1)
					READ_ASCII (j + 1) tail (length - j - 1)
				END
			END
		END
		ACTION_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT tail ~%json%~
		END
	END	
	
	
	
DEFINE_ACTION_FUNCTION consume_json_list
	STR_VAR json = ~~
	RET
		consumed
		tail
	BEGIN
		OUTER_TEXT_SPRINT consumed ~~		
		LAF string_prefix_length 
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET offset = length length = srclength acc = next END

		ACTION_IF offset < length - 1 AND ~%acc%~ STR_EQ ~[~ THEN BEGIN //[] takes two characters at least
			LAF SUBSTRING
				INT_VAR start = offset + 1 length = length - offset - 1
				STR_VAR string = EVALUATE_BUFFER ~%json%~
				RET tail = substring END

			OUTER_TEXT_SPRINT consumed ~[~ //anything just to enter the loop
			OUTER_WHILE NOT ~%consumed%~ STR_EQ ~~ BEGIN
				ACTION_IF NOT ~%consumed%~ STR_EQ ~[~ THEN BEGIN
					OUTER_TEXT_SPRINT acc ~%acc%, %consumed%~
					
					LAF string_prefix_length
						STR_VAR 
							string = EVALUATE_BUFFER ~%tail%~ 
							char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
						RET offset = length length = srclength consumed = next END
					
					ACTION_IF ~%consumed%~ STR_EQ ~,~ THEN BEGIN
						LAF SUBSTRING 
							INT_VAR start = offset + 1 length = length - offset - 1
							STR_VAR string = EVALUATE_BUFFER ~%tail%~
							RET tail = substring END
					END ELSE BEGIN
						OUTER_TEXT_SPRINT consumed ~~
					END
				END

				ACTION_IF NOT ~%consumed%~ STR_EQ ~~ THEN BEGIN
					LAF consume_json STR_VAR json = EVALUATE_BUFFER ~%tail%~ RET consumed tail END
				END
			END
			
			LAF string_prefix_length 
				STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
				RET offset = length length = srclength next END				

			ACTION_IF ~%next%~ STR_EQ ~]~ THEN BEGIN
				OUTER_TEXT_SPRINT consumed ~%acc%]~

				LAF SUBSTRING
					INT_VAR start = offset + 1 length = length - offset - 1
					STR_VAR string = EVALUATE_BUFFER ~%tail%~
					RET tail = substring END
			END
		END
		ACTION_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN //no ']' meaning invalid json, revert tail
			OUTER_TEXT_SPRINT tail ~%json%~
		END

	END
	
	
	
DEFINE_ACTION_FUNCTION consume_json_object_property
	STR_VAR
		json = ~~
	RET
		property
		value
		tail
	BEGIN
		LAF consume_json_string STR_VAR json = EVALUATE_BUFFER ~%json%~ RET property = consumed tail END
		OUTER_TEXT_SPRINT value ~~		
		
		ACTION_IF NOT ~%property%~ STR_EQ ~~ THEN BEGIN //%property% contains the name of the next property

			LAF string_prefix_length 
				STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
				RET offset = length length = srclength next END
			
			ACTION_IF ~%next%~ STR_EQ ~:~ BEGIN
				LAF SUBSTRING
					INT_VAR start = offset + 1 length = length - offset - 1
					STR_VAR string = EVALUATE_BUFFER ~%tail%~
					RET tail = substring END
				LAF consume_json //read the value of the property
					STR_VAR json = EVALUATE_BUFFER ~%tail%~ 
					RET value = consumed tail END			
			END
			
			ACTION_IF ~%value%~ STR_EQ ~~ THEN BEGIN //no property value - invalid json
				OUTER_TEXT_SPRINT property ~~
				OUTER_TEXT_SPRINT tail ~%json%~
			END ELSE BEGIN
				LAF string_prefix_length 
					STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
					RET length srclength next END
				ACTION_IF ~%next%~ STR_EQ ~,~ THEN BEGIN
					LAF SUBSTRING
						INT_VAR start = length + 1 length = srclength - length - 1
						STR_VAR string = EVALUATE_BUFFER ~%tail%~
						RET tail = substring END
				END

			END
		END
	END



DEFINE_ACTION_FUNCTION consume_json_object
	STR_VAR 
		json = ~~
	RET
		consumed
		tail
	BEGIN
		OUTER_TEXT_SPRINT consumed ~~
		LAF string_prefix_length
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET length srclength acc = next END

		ACTION_IF length < srclength - 1 AND ~%acc%~ STR_EQ ~{~ BEGIN
			LAF SUBSTRING
				INT_VAR start = length + 1 length = srclength - length - 1
				STR_VAR string = EVALUATE_BUFFER ~%json%~
				RET tail = substring END				
			LAF consume_json_object_property 
				STR_VAR json = EVALUATE_BUFFER ~%tail%~
				RET property value tail END //will consume a trailing ',' for us
			
			OUTER_WHILE NOT ~%property%~ STR_EQ ~~ BEGIN 
				ACTION_IF ~%acc%~ STR_EQ ~{~ THEN BEGIN
					OUTER_TEXT_SPRINT acc ~{%property%: %value%~
				END ELSE BEGIN
					OUTER_TEXT_SPRINT acc ~%acc%, %property%: %value%~
				END
				
				LAF consume_json_object_property 
					STR_VAR json = EVALUATE_BUFFER ~%tail%~
					RET property value tail END //will consume a trailing ',' for us
			
			END
			
			LAF string_prefix_length
				STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
				RET length srclength next END
			
			ACTION_IF ~%next%~ STR_EQ ~}~ THEN BEGIN
				OUTER_TEXT_SPRINT consumed ~%acc%}~
				LAF SUBSTRING
					INT_VAR start = length + 1 length = srclength - length - 1
					STR_VAR string = EVALUATE_BUFFER ~%tail%~ 
					RET tail = substring END
			END
		END			

		ACTION_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN //no '}' means invalid json, revert %tail%~
			OUTER_TEXT_SPRINT tail ~%json%~
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION consume_json
	STR_VAR json = ~~
	RET
		consumed
		tail
	BEGIN
		LAF string_prefix_length
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET peek = next END
		ACTION_IF ~%peek%~ STR_EQ ~{~ THEN BEGIN
			LAF consume_json_object STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END ELSE ACTION_IF ~%peek%~ STR_EQ ~[~ THEN BEGIN
			LAF consume_json_list STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END ELSE ACTION_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN
			LAF consume_json_string STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END ELSE ACTION_IF ~%peek%~ STR_EQ ~t~ OR ~%peek%~ STR_EQ ~f~ THEN BEGIN
			LAF consume_json_boolean STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END ELSE ACTION_IF ~%peek%~ STR_EQ ~n~ THEN BEGIN
			LAF consume_json_null STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END ELSE BEGIN
			LAF consume_json_number STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		END
		
	END
	
	
	
	
	

DEFINE_ACTION_MACRO json_internal_consumed_valid_json BEGIN
	ACTION_IF ~%consumed%~ STR_EQ ~~ THEN BEGIN
		OUTER_SET is_json = 0
	END ELSE BEGIN
		LAF string_prefix_length 
			STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET length srclength END
		OUTER_SET is_json = length == srclength
	END
END

DEFINE_ACTION_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		LAF consume_json_null STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed END
		LAM json_internal_consumed_valid_json
		OUTER_SET is_null = is_json
	END
	
	
	
DEFINE_PATCH_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_null STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_null END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		LAF consume_json_boolean STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
		OUTER_SET is_boolean = is_json
	END
	
	
	
DEFINE_PATCH_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_boolean STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_boolean END
		END
	END
	
	

DEFINE_ACTION_FUNCTION is_json_int
	STR_VAR json = ~~
	RET is_int
	BEGIN
		LAF consume_json_number STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
		OUTER_SET is_int = is_json
	END



DEFINE_PATCH_FUNCTION is_json_int
	STR_VAR json = ~~
	RET is_int
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_int STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_int END
		END
	END
	
	
	
 DEFINE_ACTION_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		OUTER_SET is_string = 1
		ACTION_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET is_string = 0
		END
	END
	
	

DEFINE_PATCH_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		SET is_string = 1
		PATCH_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			SET is_string = 0
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION is_json_list
	STR_VAR json = ~~
	RET is_list
	BEGIN
		LAF consume_json_list STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
		OUTER_SET is_list = is_json
	END
	
	

DEFINE_PATCH_FUNCTION is_json_list
	STR_VAR json = ~~
	RET is_list
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_list STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_list END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		LAF consume_json_object STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
		OUTER_SET is_object = is_json
	END



DEFINE_PATCH_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_object STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_object END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		LAF consume_json STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
	END



DEFINE_PATCH_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		INNER_ACTION BEGIN
			LAF is_valid_json STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_json END
		END
	END	
	
	
	




/*
DEFINE_ACTION_FUNCTION json_to_null
	STR_VAR json = ~~
	RET res
	BEGIN
		ACTION_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%null%WHITESPACE_RX%$~ THEN BEGIN
			FAIL ~Expected Json null but got: >>%json%<<.~
		END
		OUTER_TEXT_SPRINT res ~null~
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_null
	STR_VAR json = ~~
	RET res
	BEGIN
		PATCH_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%null%WHITESPACE_RX%$~ THEN BEGIN
			FAIL ~Expected Json null but got: >>%json%<<.~
		END
		OUTER_TEXT_SPRINT res ~null~	
	END
*/		
		

DEFINE_ACTION_FUNCTION json_to_boolean
	STR_VAR json = ~~
	RET res
	BEGIN
		LAM trim_json
		ACTION_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF ~%json%~ STR_EQ ~false~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE BEGIN
			FAIL ~Expected a Json Boolean but got: >>%json%<<.~
		END
	END
		
		
		
DEFINE_PATCH_FUNCTION json_to_boolean
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_boolean STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_int
	STR_VAR json = ~~
	RET res
	BEGIN
		LAF consume_json_number STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		OUTER_SET res = consumed
		
		LAM json_internal_consumed_valid_json
		ACTION_IF NOT is_json THEN BEGIN
			FAIL ~Expected a Json number but got: >>%json%<<.~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_int
	STR_VAR json = ~~
	RET res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_int STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		LAF consume_json_string STR_VAR json = EVALUATE_BUFFER ~%json%~ RET consumed tail END
		LAM json_internal_consumed_valid_json
		ACTION_IF NOT is_json THEN BEGIN
			FAIL ~Expected a Json string but got: >>%json%<<.~
		END
		OUTER_SET length = STRING_LENGTH consumed
		LAF SUBSTRING
			INT_VAR start = 1 length = length - 2
			STR_VAR string = EVALUATE_BUFFER ~%consumed%~ 
			RET substring END
		LAF json_unescape_str STR_VAR json = EVALUATE_BUFFER ~%substring%~ RET res END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_string STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
		END
	END
	
	
/*	
DEFINE_ACTION_MACRO json_to_json_array_internal BEGIN
	LOCAL_SPRINT elem ~~
	ACTION_IF NOT ~%internal_json_array_tail%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%$~ THEN BEGIN
		FAIL ~Unterminated Json array: %json%~ //handles also empty string 
	END
	OUTER_PATCH_SAVE internal_json_array_tail ~%internal_json_array_tail%~
		REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^%WHITESPACE_RX%]%WHITESPACE_RX%$~ ~~
	END
	ACTION_IF NOT ~%internal_json_array_tail%~ STR_EQ ~~ THEN BEGIN
		LAF consume_json 
			STR_VAR json = EVALUATE_BUFFER ~%internal_json_array_tail%~ 
			RET elem = consumed internal_json_array_tail = tail END
		
		ACTION_IF ~%elem%~ STR_EQ ~~ THEN BEGIN //invalid json
			FAIL ~Expected a Json array but got: >>%json%<< (error at %internal_json_array_tail%).~ 
		END ELSE BEGIN
			OUTER_PATCH_SAVE internal_json_array_tail ~%internal_json_array_tail%~ BEGIN
				REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^%WHITESPACE_RX%,~ ~~
			END
			
			OUTER_TEXT_SPRINT $res(%length%) ~%elem%~
			OUTER_SET length += 1
		
			LAM json_to_json_array_internal 
		END
	END
	
END	
*/	
	
DEFINE_ACTION_FUNCTION json_to_json_array
	STR_VAR json = ~~
	RET length
	RET_ARRAY res 
	BEGIN
		OUTER_SET length = 0
		ACTION_DEFINE_ARRAY res BEGIN END
		OUTER_SET invalid = 1
		
		OUTER_PATCH_SAVE tail ~%json%~ BEGIN
			REPLACE_EVALUATE CASE_SENSITIVE ~^%WHITESPACE_RX%\[~ BEGIN
				SET invalid = 0
			END ~~
		END
		ACTION_IF invalid THEN BEGIN
			FAIL ~Invalid Json array: %json%~
		END
		
		LAF consume_json 
			STR_VAR json = EVALUATE_BUFFER ~%tail%~ 
			RET consumed tail END

		OUTER_WHILE NOT ~%consumed%~ STR_EQ ~~ BEGIN
			OUTER_TEXT_SPRINT $res(%length%) ~%elem%~
			OUTER_SET length += 1
			
			LAF consume_json
				STR_VAR json = EVALUATE_BUFFER ~%tail%~
				RET consumed tail END
		END
		
		ACTION_IF ~%tail%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%]~ THEN BEGIN
			FAIL ~Unterminated Json array: %json%~
		END

		ACTION_IF NOT length THEN BEGIN
			OUTER_TEXT_SPRINT $res(0) ~<empty array; check length before access>~
		END
		
	END
	
	

DEFINE_PATCH_FUNCTION json_to_json_array
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_json_array STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_array_values
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		LAF json_to_json_array STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END
		OUTER_FOR (i = 0; i < length; ++i) BEGIN
			OUTER_TEXT_SPRINT elem $res(%i%)
			ACTION_IF NOT ~%elem%~ STRING_MATCHES_REGEXP ~^true\|false$~ THEN BEGIN
				OUTER_SET $res(%i%) = ~%elem%~ STR_EQ ~true~
			
			END ELSE ACTION_IF NOT ~%elem%~ STRING_MATCHES_REGEXP ~^".*"$~ BEGIN
				LAF json_to_string STR_VAR json = EVALUATE_BUFFER ~%elem%~ RET res END
				OUTER_TEXT_SPRINT $res(%i%) ~%res%~ 
				
			END ELSE ACTION_IF IS_AN_INT $res(%i%) THEN BEGIN
				OUTER_SET $res(%i%) = $res(%i%)
			
			END ELSE BEGIN
				FAIL ~Can't convert json %elem% to a WeiDU variable inside array %json%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_array_values
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_values STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END
		END
	END



DEFINE_ACTION_FUNCTION json_array_element
	INT_VAR idx = 0
	STR_VAR json = ~~
	RET res 
	BEGIN
		ACTION_IF idx < 0 THEN BEGIN
			FAIL ~Index out of bounds: %idx% element of %json%~
		END
		OUTER_TEXT_SPRINT res ~~
		OUTER_TEXT_SPRINT consumed ~~
		
		LAF string_prefix_length
			STR_VAR string = EVALUATE_BUFFER ~%json%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
			RET length srclength next END

		OUTER_SET countdown = idx	
		
		ACTION_IF ~%next%~ STR_EQ ~[~ THEN BEGIN
			OUTER_TEXT_SPRINT res ~[~
			OUTER_WHILE NOT ~%res%~ STR_EQ ~~ AND countdown >= 0 BEGIN //json starts with '[' 
				LAF consume_json STR_VAR json = EVALUATE_BUFFER ~%tail%~ RET res = consumed tail END
				
				LAF string_prefix_length
					STR_VAR string = EVALUATE_BUFFER ~%tail%~ char_rx = EVALUATE_BUFFER ~[%WHITESPACE_CHARS%]~
					RET length srclength next END
				ACTION_IF ~%next%~ STR_EQ ~,~ THEN BEGIN
					LAF SUBSTRING
						INT_VAR start = length + 1 length = srclength - length - 1
						STR_VAR string = EVALUATE_BUFFER ~%tail%~
						RET tail = substring END
				END
			END
		END
		ACTION_IF countdown >= 0 THEN BEGIN
			FAIL ~Index out of bounds or invalid json: %idx% element of %json%~
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_array_element
	INT_VAR idx = 0
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_property INT_VAR idx = idx STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
		END
	END



/*	
DEFINE_ACTION_MACRO json_to_json_object_internal BEGIN
	LOCAL_SPRINT field ~~
	LOCAL_SPRINT value ~~
	
	ACTION_IF NOT ~%internal_json_object_tail%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%$~ THEN BEGIN
		FAIL ~Unterminated Json object: %json%~ //handles also empty string 
	END
	OUTER_PATCH_SAVE internal_json_object_tail ~%internal_json_object_tail%~
		REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^%WHITESPACE_RX%}%WHITESPACE_RX%$~ ~~
	END
	ACTION_IF NOT ~%internal_json_object_tail%~ STR_EQ ~~ THEN BEGIN
		LAF consume_json_string //read field the next (property) name
			STR_VAR json = EVALUATE_BUFFER ~%internal_json_object_tail%~ 
			RET field = consumed internal_json_object_tail = tail END
		
		ACTION_IF ~%field%~ STR_EQ ~~ //invalid json
		       OR ~%internal_json_object_tail%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%:~ THEN BEGIN 
			FAIL ~Expected a Json object but got: >>%json%<< (error near %internal_json_object_tail%).~ 
		END ELSE BEGIN
			OUTER_PATCH_SAVE internal_json_object_tail ~%internal_json_object_tail%~ BEGIN
				REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^WHITESPACE%:~ ~~ //drop the ':' separator
			END
			LAF consume_json //read the property associated value
				STR_VAR json = EVALUATE_BUFFER ~%internal_json_object_tail%~
				RET value = consumed internal_json_object_tail = tail END
			
			ACTION_IF ~%value%~ STR_EQ ~~ THEN BEGIN //invalid json
				FAIL ~Expected a Json object but got: >>%json%<< (error near %internal_json_object_tail%).~
			END ELSE BEGIN
				OUTER_PATCH_SAVE internal_json_object_tail ~%internal_json_object_tail%~ BEGIN
					REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^%WHITESPACE_RX%,~ ~~ //drop any ','
				END
				
				LAF json_unescape_str STR_VAR json = EVALUATE_BUFFER ~%field%~ RET field = res END
				OUTER_TEXT_SPRINT $res(~%field%~) ~%value%~
				OUTER_SET length += 1
			
				LAM json_to_json_object_internal 
			END
		END
	END
	
END	
*/	
	
	
DEFINE_ACTION_FUNCTION json_to_field_array
	STR_VAR json = ~~
	RET length
	RET_ARRAY res 
	BEGIN
		OUTER_SET length = 0
		ACTION_DEFINE_ASSOCIATIVE_ARRAY res BEGIN END
		OUTER_SET invalid = 1
		
		OUTER_PATCH_SAVE tail ~%json%~ BEGIN
			REPLACE_EVALUATE ~^%WHITESPACE_RX%{~ BEGIN
				SET invalid = 0
			END ~~
		END
		ACTION_IF invalid THEN BEGIN
			FAIL ~Expected a Json object but got: >>%json%<<.~
		END
		
		LAF consume_json_object_property STR_VAR json = EVALUATE_BUFFER ~%tail%~ RET property value tail END

		OUTER_WHILE NOT ~%property%~ STR_EQ ~~ BEGIN
			OUTER_SET length += 1
			LAF json_to_string STR_VAR json = EVALUATE_BUFFER ~%property%~ RET name = res END			
			OUTER_TEXT_SPRINT $res(~%name%~) ~%value%~

			LAF consume_json_object_property STR_VAR json = EVALUATE_BUFFER ~%tail%~ RET property value tail END
		END

		ACTION_IF ~%tail%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%}~ THEN BEGIN
			FAIL ~Unterminated Json object: %json%~
		END

		ACTION_IF NOT length THEN BEGIN
			OUTER_TEXT_SPRINT $res(~~) ~<empty array; check length before access>~
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_to_field_array
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_field_array STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_field_values
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		LAF json_to_field_array STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END

		ACTION_IF length BEGIN
			ACTION_PHP_EACH res AS name => value BEGIN
				ACTION_IF NOT ~%value%~ STRING_MATCHES_REGEXP ~^true\|false$~ THEN BEGIN
					OUTER_SET $res(~%name%~) = ~%value%~ STR_EQ ~true~
			
				END ELSE ACTION_IF NOT ~%value%~ STRING_MATCHES_REGEXP ~^".*"$~ BEGIN
					LAF json_to_string STR_VAR json = ~%value%~ RET value = res END
					OUTER_TEXT_SPRINT $res(~%name%~) ~%value%~
				END ELSE ACTION_IF IS_AN_INT ~%value%~ THEN BEGIN
					OUTER_SET $res(~%name%~) = %value%
				
				END ELSE BEGIN
					FAIL ~Can't convert json property %name%: %value% to a WeiDU variable inside object %json%~
				END
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_field_values
	STR_VAR json = ~~
	RET length
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_field_values STR_VAR json = EVALUATE_BUFFER ~%json%~ RET length RET_ARRAY res END
		END
	END



	
	
	
DEFINE_ACTION_FUNCTION json_object_field	
	STR_VAR
		json = ~~
		field = ~~
	RET	res
	BEGIN
		OUTER_TEXT_SPRINT property ~~
		OUTER_TEXT_SPRINT res ~~
		
		OUTER_PATCH_SAVE tail ~%json%~ BEGIN
			REPLACE_EVALUATE CASE_SENSITIVE ~^%WHITESPACE_RX%{~ BEGIN
				TEXT_SPRINT property ~{~ //just to enter the loop below
			END ~~
		END
		
		OUTER_WHILE NOT ~%property%~ STR_EQ ~~ AND NOT ~%property%~ STR_EQ ~%field%~ BEGIN
			LAF consume_json_object_property STR_VAR json = ~%tail%~ RET property res = value tail END
		END
		
		ACTION_IF NOT ~%property%~ STR_EQ ~%field%~ BEGIN
			OUTER_TEXT_SPRINT res ~~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_object_field
	STR_VAR
		json = ~~
		field = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_object_field 
				STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~
				RET res END
		END
	END
	
		
	




DEFINE_ACTION_FUNCTION json_value
	STR_VAR 
		json = ~~
		type = ~~
	RET	res
	BEGIN
		ACTION_MATCH ~%type%~ WITH
			~number\|int~ BEGIN 
				LAF json_to_int STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
			END
			~boolean~ BEGIN
				LAF json_to_boolean STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
			END
			~string~ BEGIN
				LAF json_to_string STR_VAR json = EVALUATE_BUFFER ~%json%~ RET res END
			END
			DEFAULT
				FAIL ~Can't cast Json to %type%: %json%~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_value
	STR_VAR
		json = ~~
		type = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_value STR_VAR json = EVALUATE_BUFFER ~%json%~ type = EVALUATE_BUFFER ~%type%~ RET res END
		END
	END



	
	

DEFINE_ACTION_FUNCTION get_json_property
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		OUTER_TEXT_SPRINT res ~~
		
		ACTION_IF ~%property%~ STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT res ~%json%~
		
		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^\[~ THEN BEGIN //json array
			OUTER_PATCH_SAVE property ~%property%~ BEGIN
				REPLACE_EVALUATE CASE_SENSITIVE ~^\[\([0-9]+\)\]\(.*\)$~ BEGIN
					SET idx = ~%MATCH1%~
					LPF json_array_element 
						INT_VAR idx = idx 
						STR_VAR json = EVALUATE_BUFFER ~%json%~ 
						RET elem = res END
						
					PATCH_IF NOT ~%elem%~ STR_EQ ~~ THEN BEGIN
						LPF get_json_property 
							STR_VAR 
								json = EVALUATE_BUFFER ~%elem%~ 
								property = EVALUATE_BUFFER ~%MATCH2%~
								type = EVALUATE_BUFFER ~%type%~
							RET res END	
					END				
				END ~~
			END
		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^{~ THEN BEGIN //json object			
			
			LAF json_to_property_array 
				STR_VAR json = EVALUATE_BUFFER ~%json%~ 
				RET length 
				RET_ARRAY fields = res END		
			
			ACTION_IF length THEN BEGIN
				OUTER_TEXT_SPRINT prefix ~%property%~
				OUTER_TEXT_SPRINT suffix ~~
				
				//iterate over property prefixes of %property% in decreasing length in search for a matching property
				OUTER_WHILE NOT ~%prefix%~ STR_EQ ~~ BEGIN 
					ACTION_IF VARIABLE_IS_SET $property(~%prefix%~) THEN BEGIN
						//we have found the property; it might be a direct property named after a complex property
						OUTER_TEXT_SPRINT value $fields(~%prefix%~)

						LAF get_json_property //continue recursion with the suffix as the property
							STR_VAR 
								json = EVALUATE_BUFFER ~%value%~ 
								property = EVALUATE_BUFFER ~%suffix%~
								type = EVALUATE_BUFFER ~%type%~
							RET res END
						OUTER_TEXT_SPRINT prefix ~~ //terminate the loop
					
					END ELSE BEGIN //check the next prefix property
						OUTER_SET reduced = 0
						OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
							REPLACE_EVALUATE CASE_SENSITIVE ~\[\([0-9]+\)\]$~ BEGIN
								TEXT_SPRINT suffix ~[%MATCH1%]%suffix%~
								SET reduced = 1
							END ~~
						END
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\.\([^.]\)*$~ BEGIN
									TEXT_SPRINT suffix ~.%MATCH1%%suffix%~
									SET reduced = 1
								END ~~
							END
						END
						ACTION_IF NOT reduced THEN BEGIN //%property% is a simple property
							OUTER_TEXT_SPRINT suffix ~%prefix%%suffix%~
							OUTER_TEXT_SPRINT prefix ~~							
						END
					END
				END
			END
		END
		
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_property	
	STR_VAR 
		json = ~~
		property = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_property 
				STR_VAR json = EVALUATE_BUFFER ~%json%~ property = EVALUATE_BUFFER ~%property%~
				RET res END
		END
	END
	
	

DEFINE_ACTION_FUNCTION json_get_value 
	STR_VAR
		json = ~~
		property = ~~
	RET	
		res
		exists
	BEGIN
		LAF json_get_property 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ property = EVALUATE_BUFFER ~%property%~
			RET json = res END
		LAM trim_json
		
		OUTER_SET exists = 1
		ACTION_IF ~%j%~ STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT res ~~
			OUTER_SET exists = 0
		END ELSE ACTION_IF IS_AN_INT ~%j%~ THEN BEGIN
			OUTER_SET res = ~%j%~
		END ELSE ACTION_IF ~%j%~ STR_EQ ~true~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF ~%j%~ STR_EQ ~false~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE ACTION_IF NOT ~%j%~ STRING_MATCHES_REGEXP ~^%JSON_STRING_RX%$~ THEN BEGIN
			LAF json_to_string STR_VAR json = EVALUATE_BUFFER ~%j%~ RET res END
		END ELSE BEGIN
			FAIL ~Can't convert Json %json% to a WeiDU variable~
		END
	END
		
		
		
DEFINE_PATCH_FUNCTION json_get_value 	
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
		exists
	BEGIN
		INNER_ACTION BEGIN
			LAF json_get_value 
				STR_VAR 
					json = EVALUATE_BUFFER ~%json%~ 
					property = EVALUATE_BUFFER ~%property%~
				RET res exists END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION json_get_boolean
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LAF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~boolean~
			RET res exists END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_get_boolean
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LPF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~boolean~
			RET res exists END
	END
	
	
		
DEFINE_ACTION_FUNCTION json_get_int
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LAF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~int~
			RET res exists END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_get_int
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LPF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~int~
			RET res exists END
	END
	
	
		
DEFINE_ACTION_FUNCTION json_get_string
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LAF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~string~
			RET res exists END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_get_string
	STR_VAR 
		json = ~~
		field = ~~
	RET
		res
		exists
	BEGIN
		LPF json_get_value 
			STR_VAR json = EVALUATE_BUFFER ~%json%~ field = EVALUATE_BUFFER ~%field%~ type = ~string~
			RET res exists END
	END
	


DEFINE_ACTION_FUNCTION json_get_array
	STR_VAR
		json = ~~
		field = ~~
	RET
		length
		exists
	RET_ARRAY
		res
	BEGIN
	END







DEFINE_ACTION_FUNCTION read_json_file
	STR_VAR file = ~~
	RET json
	BEGIN
		OUTER_SET size = SIZE_OF_FILE ~%file%~
		COPY ~%file%~ ~%MOD_FOLDER%~ //just read
			READ_ASCII 0 json (%size%) NULL 
		BUT_ONLY_IF_IT_CHANGES
		LAF is_valid_json STR_VAR json = EVALUATE_BUFFER ~%json%~ RET is_json END
		ACTION_IF NOT is_json THEN BEGIN
			FAIL ~File %file% does not contain valid Json data: 
%json%~
		END
	END


END //JSON4WEIDU	