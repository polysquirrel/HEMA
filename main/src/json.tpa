ACTION_IF NOT VARIABLE_IS_SET JSON4WEIDU THEN BEGIN
OUTER_TEXT_SPRINT JSON4WEIDU ~JSON4WEIDU~ 

ACTION_IF NOT VARIABLE_IS_SET BHAALSSON_DIR THEN BEGIN
	OUTER_TEXT_SPRINT BHAALSSON_DIR ~%MOD_FOLDER%~
END
INCLUDE ~%BHAALSSON_DIR%/stringutil.tpa~


/*************************************************************************************
 ********************                                             ********************
 ********************   Functions for working with json strings   ********************
 ********************                                             ********************
 *************************************************************************************/ 


/** The character used to separate individual keys/indexing in complex properties forming
  * paths to deeply nested elements. See get_json/set_json.
  */
OUTER_TEXT_SPRINT JSON_PROPERTY_SEPARATOR ~.~

/** Regexp matching any sequence of '\' terminated by a character other than '"' and '\', 
  * or an odd sequence of '\' terminated by '"'. */
OUTER_TEXT_SPRINT JSON_STRING_ATOM_RX ~\(\\*[^\"]\|\([^\]\\\(\\\\\)*"\)\)~
/** Any string surrounded by a pair of '"' characters, in which all '"' are escaped with a '\'.*/
OUTER_TEXT_SPRINT JSON_STRING_RX ~"\(\(\\\(\\\\\)*"\)?\(%JSON_STRING_ATOM_RX%*\)\(\(\\\\\)*\)\)"~ 

OUTER_TEXT_SPRINT JSON_REGEXP_RX ~[rR]%JSON_STRING_RX%~

OUTER_TEXT_SPRINT JSON_NULL ~null~

OUTER_TEXT_SPRINT JSON_TRUE ~true~
OUTER_TEXT_SPRINT JSON_FALSE ~false~

OUTER_SET MAX_INT = BIT31 - 1 //2147483647
 





/*************************************************************************************
 ********************     String-related util functions           ********************
 *************************************************************************************/ 



/** Trims all whitespace from the front of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json_front BEGIN
	LAF trim_string_front STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the front of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json_front BEGIN
	LPF trim_string_front STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the back of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json_back BEGIN
	LAF trim_string_back STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the back of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json_back BEGIN
	LPF trim_string_back STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from both ends of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json BEGIN
	LAF trim_string STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from both ends of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json BEGIN
	LPF trim_string STR_VAR string = EVAL ~%json%~ RET json = res END
END



DEFINE_PATCH_FUNCTION report_invalid_json
	INT_VAR at = 0 - 1
	STR_VAR msg = ~~
	BEGIN
		PATCH_IF at < 0 THEN BEGIN
			PATCH_IF VARIABLE_IS_SET offset THEN BEGIN
				SET at = offset
			END ELSE BEGIN
				SET at = 0
			END
		END
		SET start = at - 100
		PATCH_IF start < 0 THEN BEGIN
			SET start = 0
		END
		READ_ASCII start fragment (at - start)
		TEXT_SPRINT peek ~~
		PATCH_IF at < BUFFER_LENGTH THEN BEGIN
			READ_ASCII at peek (1)
		END
		PATCH_IF ~%msg%~ STR_EQ ~~ THEN BEGIN
			PATCH_FAIL ~Invalid_json at #%at%: '%peek%' following <<%fragment%>>.~
		END ELSE BEGIN
			PATCH_FAIL ~%msg% at #%at%: '%peek%' following <<%fragment%>>.~
		END
	END
		





/** Replaces all '"' and '\' characters in the input string by '\"' and '\\' respectively. */
DEFINE_ACTION_FUNCTION json_escape_str
	STR_VAR	str = ~~
	RET	res 
	BEGIN
		OUTER_PATCH_SAVE res ~%str%~ BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
			REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		END
	END
 
 

/** Replaces all '"' and '\' characters in the input string by '\"' and '\\' respectively. */ 
 DEFINE_PATCH_FUNCTION json_escape_str
	STR_VAR str = ~~
	RET res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_escape_str STR_VAR str = EVAL ~%str%~ RET res END
		END
	END



	

 
/*************************************************************************************
 ********************    Writing json to the patch buffer        ********************
 *************************************************************************************/ 


/** Inserts the given boolean value in the json format (true|false) into the currently patched
  * buffer at the given offset, pushing back any existing data. The value can be given either
  * as an integer %boolean% and interpreted as by WeiDU, or as an (unquoted) string %json%: 
  * 'true' or 'false'. The latter parameter, if not empty, takes precedence.
  * If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  * Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_boolean
	INT_VAR 
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
		/** Integer value to write as json; 0 results in writing 'false', any other value in 'true' */
		boolean = 0
	STR_VAR
		/** Boolean to write in the string format: either 'true' or 'false'. 
		  * If empty, the %boolean% parameter will be used instead. */
		json = ~~
	RET 
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		PATCH_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			SET boolean = 1
		END ELSE PATCH_IF ~%json%~ STR_EQ ~false~ THEN BEGIN
			SET boolean = 0
		END ELSE PATCH_IF NOT ~%json%~ STR_EQ ~~ THEN BEGIN
			PATCH_FAIL ~write_json_boolean: argument json=<<%json%> is not a valid json boolean.~
		END
		
		PATCH_IF boolean THEN BEGIN
			INSERT_BYTES offset 4
			WRITE_ASCII offset ~true~
			SET offset += 4
		END ELSE BEGIN
			INSERT_BYTES offset 5
			WRITE_ASCII offset ~false~
			SET offset += 5
		END
	END



/** Inserts the given integer value into the currently patched
  * buffer at the given offset, pushing back any existing data. The value can be given either
  * as an integer %number% and interpreted as by WeiDU, or as an (unquoted) string %json%: 
  * 'true' or 'false'. The latter parameter, if not empty, takes precedence.
  * If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  * Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_number
	INT_VAR 
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
		/** Integer value to write as json. */
		number = 0
	STR_VAR
		/** Integer to write in a valid json format: decimal, hexadecimal (prefixed with '0x'),
		  * or octal (prefixed with '0o'). A leading sign (-/+) is allowed. If empty, the %number%
		  * parameter is used instead. */
		json = ~~
	RET 
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		PATCH_IF ~%json%~ STR_EQ ~~ THEN BEGIN
			SET json = ~%number%~
		END ELSE BEGIN
			LPF is_json_number STR_VAR json = EVAL ~%json%~ RET is_number END
			PATCH_IF NOT is_number THEN BEGIN
				PATCH_FAIL ~write_json_number: <<%json%>> is not a number.~
			END
		END
			
		SET len = STRING_LENGTH ~%json%~
		INSERT_BYTES offset len
		WRITE_ASCIIE offset ~%json%~ 		
		SET offset += len
	END



/** Inserts the given string into the currently patched buffer at the given offset, 
  * pushing back any existing data. The value can be given either as an ordinary string %string%,
  * or as an already quoted value %json% (surrounded in '"' with any '"' inside escaped with '\').
  * The latter parameter, if not empty, takes precedence.
  * If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  * Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_string
	INT_VAR 
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
	STR_VAR
		/** String value to format as a json string and write into the buffer. */
		string = ~~
		/** A string to write in valid json format: quoted with '"', with any '"' and '\' preceded by a'\'. */
		json = ~~
	RET 
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		PATCH_IF ~%json%~ STR_EQ ~~ THEN BEGIN //write %string% to the buffer after transforming it to json
			INNER_PATCH_SAVE escaped ~%string%~ BEGIN
				REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~\~ ~\\\\~
				REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~"~ ~\"~
			END 
			SET length = STRING_LENGTH ~%escaped%~
			INSERT_BYTES offset (length + 2)
			WRITE_ASCII offset ~"~
			WRITE_ASCIIE (offset + 1) ~%escaped%~
			WRITE_ASCII (offset + 1 + length) ~"~		
			SET offset += length + 2

		END ELSE BEGIN
			LPF is_json_string STR_VAR json = EVAL ~%json%~ RET is_string END
			PATCH_IF NOT is_string THEN BEGIN
				PATCH_FAIL ~write_json_string: argument json=<<%json%>> is not a json string.~
			END
			SET length = STRING_LENGTH ~%json%~
			INSERT_BYTES offset length
			WRITE_ASCIIE offset ~%json%~
			SET offset += length
		END
	END
	
	

/** Inserts the given value into the currently patched buffer at the given offset, 
  * pushing back any existing data. The value, given as a string parameter %value%, is
  * written as a json string, unless it is a valid integer as returned by WeiDU's IS_AN_INT function,
  * in which case it is written as a number.
  * If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  * Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_atom
	INT_VAR 
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
	STR_VAR
		/** The value to convert to json and write into the buffer. */
		value = ~~
	RET 
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF IS_AN_INT ~%value%~ THEN BEGIN
			LPF write_json_number INT_VAR offset = offset number = value RET offset END
		END ELSE BEGIN
			LPF write_json_string 
				INT_VAR offset = offset 
				STR_VAR string = EVAL ~%value%~ 
				RET offset
			END
		END
	END
	
	

/**  Writes the contents of a given array at the given offset in the currently patched buffer
  *  as a json array. If the %rawarray% parameter is not empty, it assumed to be the name
  *  of an existing weidu array construct, which elements are all already valid json values.
  *  Otherwise, the %array% parameter is assumed to be the name of a WeiDU array which contents
  *  must yet be formatted as json values. If an element can be parsed as a number, it will be
  *  written as such; otherwise it will be formatted as a json string.
  *  If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  *  Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_array 
	INT_VAR
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
		/** If the %size% parameter is specified, only that many first elements of the array will be written. */
		size = 2147483647
	STR_VAR
		/** Name of an array containing valid json values. */
		rawarray = ~~
		/** Name of an array containing values to be formatted as json; checked only 
		  * if the %rawarray% parameter is an empty string. */
		array = ~~
	RET
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH	
		END 
		PATCH_IF size <= 0 THEN BEGIN
			INSERT_BYTES offset 2
			WRITE_ASCII offset ~[]~
			SET offset += 2
		
		END ELSE BEGIN			
			INSERT_BYTES offset 1
			WRITE_ASCII offset ~[~
			SET offset += 1
			SET i = 0
			
			PATCH_IF NOT ~%rawarray%~ STR_EQ ~~ THEN BEGIN
				PHP_EACH ~%rawarray%~ AS _ => json BEGIN
					PATCH_IF i < size THEN BEGIN
						PATCH_IF i THEN BEGIN
							INSERT_BYTES offset 2
							WRITE_ASCII offset ~, ~
							SET offset += 2
						END
						LPF write_json 
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%json%~
							RET offset
						END	
					END
					SET i += 1
				END
			
			END ELSE PATCH_IF NOT ~%array%~ STR_EQ ~~ THEN BEGIN
				PHP_EACH ~%array%~ AS _ => value BEGIN
					PATCH_IF i < size THEN BEGIN
						PATCH_IF i THEN BEGIN
							INSERT_BYTES offset 2
							WRITE_ASCII offset ~, ~
							SET offset += 2
						END
						
						LPF write_json_atom 
							INT_VAR offset = offset 
							STR_VAR value = EVAL ~%value%~
							RET offset
						END
					END
					SET i += 1
				END
			END
			
			INSERT_BYTES offset 1
			WRITE_ASCII offset ~]~
			SET offset += 1
		END
	END
	
	

/**  Writes the contents of a given array at the given offset in the currently patched buffer
  *  as a json object. The keys in the array are used as field names for their associated values.
  *  If the %rawfields% parameter is not empty, it assumed to be the name of an existing weidu array, 
  *  which keys are valid (quoted) json strings and elements are all already valid json values.
  *  Otherwise, if the %fields% parameter is not empty, it assumed to be the name of an existing array,
  *  which keys are arbitrary string values and need quoting before writing, but values are already
  *  formatted json. Lastly, the %dict% parameter is assumed to be the name of a WeiDU array which both
  *  keys and values need converting to json before writing. Keys are always formatted as strings; 
  *  if a value can be parsed as a number, it will be written as such; otherwise it will be quoted as astring.
  *  If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  *  Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json_object
	INT_VAR
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
		/** If the %size% parameter is specified, only that many first elements of the array will be written. */
		size = 2147483647
	STR_VAR
		/** Name of an array which keys are quoted strings and values are valid json. */
		rawfields = ~~
		/** Name of an array which keys are arbitrary strings and values are valid json. 
		  * Checked only if the %rawfields% parameter is an empty string. */
		fields = ~~		
		/** Name of an array which both keys and values need formatting as json. 
		  * Checked only if both the %rawfields% and %fields% parameters are empty strings. */
		dict = ~~		
	RET
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH	
		END

		INSERT_BYTES offset 1
		WRITE_ASCII offset ~{~
		SET offset += 1
		SET i = 0
		
		TEXT_SPRINT array ~~
		SET format = 0
		PATCH_IF NOT ~%rawfields%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%rawfields%~
			SET format = 1
		END ELSE PATCH_IF NOT ~%fields%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%fields%~ 
			SET format = 2
		END ELSE PATCH_IF NOT ~%dict%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%dict%~
			SET format = 3
		END
		
		PATCH_IF format AND size >= 0 THEN BEGIN
			PHP_EACH ~%array%~ AS field => value BEGIN
				PATCH_IF i < size THEN BEGIN 
					PATCH_IF i THEN BEGIN
						INSERT_BYTES offset 2
						WRITE_ASCII offset ~, ~
						SET offset += 2
					END
					
					PATCH_IF format = 1 THEN BEGIN
						LPF write_json_string 
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%field%~ 
							RET offset END
					END ELSE BEGIN
						LPF write_json_string
							INT_VAR offset = offset
							STR_VAR string = EVAL ~%field%~
							RET offset END
					END
						
					INSERT_BYTES offset 2 
					WRITE_ASCII offset ~: ~
					SET offset += 2
					
					PATCH_IF format = 3 THEN BEGIN
						LPF write_json_atom
							INT_VAR offset = offset
							STR_VAR value = EVAL ~%value%~
							RET offset END
					END ELSE BEGIN
						LPF write_json
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%value%~
							RET offset END
					END
				END
				SET i += 1
			END
		END
		
		INSERT_BYTES offset 1
		WRITE_ASCII offset ~}~
		SET offset += 1
	END
	


/**  Writes given json data at the specified offset in the currently patched buffer.
  *  The argument must be in valid json format.
  *  If the %offset% parameter is not specified or is negative, the value will be appended to the buffer. 
  *  Offset larger than the length of the buffer will result in an error.
  */
DEFINE_PATCH_FUNCTION write_json
	INT_VAR 
		/** Offset in the buffer after which the value will be written. */
		offset = 0 - 1
	STR_VAR
		/** Formatted json data to write. */
		json = ~~
	RET 
		/** Offset in the patched buffer immediately after the written value. */
		offset
	BEGIN
		SET write_offset = offset
		INNER_PATCH ~%json%~ BEGIN
			LPF skip_json INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			PATCH_IF NOT is_json THEN BEGIN
				PATCH_FAIL ~write_json: invalid json <<%json%>>.~
			END
			SET length = BUFFER_LENGTH
		END
		INSERT_BYTES write_offset length
		WRITE_ASCIIE write_offset ~%json%~
		SET offset = write_offset + length
	END






/*************************************************************************************
 ********************        Json constructor functions           ********************
 *************************************************************************************/ 



/** Returns json boolean representation ('true'/'false') based on whether the given int is non-zero. */
DEFINE_ACTION_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		ACTION_IF boolean THEN BEGIN
			OUTER_TEXT_SPRINT res ~true~
		END ELSE BEGIN
			OUTER_TEXT_SPRINT res ~false~
		END
	END
	
	

/** Returns json boolean representation ('true'/'false') based on whether the given int is non-zero. */	
DEFINE_PATCH_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		PATCH_IF boolean THEN BEGIN
			TEXT_SPRINT res ~true~
		END ELSE BEGIN
			TEXT_SPRINT res ~false~
		END
	END
	
	

/** Returns json number representation of an integer. This is most basic string formatting. */	
DEFINE_ACTION_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		OUTER_TEXT_SPRINT res ~%number%~
	END
	
	

/** Returns json number representation of an integer. This is most basic string formatting. */	
DEFINE_PATCH_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		TEXT_SPRINT res ~%number%~
	END
	
	

/** Formats the given string variable %string% for inclusion in json data. All '"' and '\'	
  * characters are preceeded by a '\' and the whole string is surrounded in a pair of '"'.
  */
DEFINE_ACTION_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN 
		OUTER_PATCH_SAVE res ~%string%~ BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
			REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		END
		OUTER_TEXT_SPRINT res ~"%res%"~
	END
	
	

/** Formats the given string variable %string% for inclusion in json data. All '"' and '\'	
  * characters are preceeded by a '\' and the whole string is surrounded in a pair of '"'.
  */	
DEFINE_PATCH_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_string STR_VAR string = EVAL ~%string%~ RET res END
		END
	END

	

/** Formats the given value as json. If it is a valid integer, it is left intact.
  * Otherwise it is quoted as a json string. 
  */
DEFINE_ACTION_FUNCTION json_atom
	STR_VAR value = ~~
	RET res
	BEGIN
		ACTION_IF IS_AN_INT ~%value%~ THEN BEGIN
			OUTER_TEXT_SPRINT res ~%value%~
		END ELSE BEGIN
			LAF json_string STR_VAR string = EVAL ~%value%~ RET res END
		END
	END
	
	

/** Formats the given value as json. If it is a valid integer, it is left intact.
  * Otherwise it is quoted as a json string. 
  */	
DEFINE_PATCH_FUNCTION json_atom
	STR_VAR value = ~~
	RET res 
	BEGIN
		PATCH_IF IS_AN_INT ~%value%~ THEN BEGIN
			TEXT_SPRINT res ~%value%~
		END ELSE BEGIN
			LPF json_string STR_VAR string = EVAL ~%value%~ RET res END
		END
	END
	
	
	
/** Formats the given weidu array $%array% or $%rawarray% for inclusion in json data. Elements of 
  * the array must be valid json strings themselves, which are concatenated, separated by
  * ', ' and surrounded by a matching pair of brackets '[' and ']'.
  * Use the %rawarray% argument for arrays which elements already are json values (including composites) 
  * themselves and %array% for arrays of weidu strings (and ints) which need converting to json before
  * formatting.
  */	
DEFINE_ACTION_FUNCTION json_array
	INT_VAR 
		/** If specified, only that many first elements of the array are included.
		  * Useful when other functions return non-empty arrays with explicitly specified
		  * zero size due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of an array construct containing the json elements to include. */
		rawarray = ~~
		/** Name of an array construct containing the values to include. 
		  * All elements will be converted to json as per json_atom. */
		array = ~~
	RET 
		/** A string containing a json array with the given elements. */	
		res
	BEGIN
		OUTER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_array 
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawarray = EVAL ~%rawarray%~
					array = EVAL ~%array%~
			END
		END
	END
	
	
	
/** Formats the given weidu array $%array% or $%rawarray% for inclusion in json data. Elements of 
  * the array must be valid json strings themselves, which are concatenated, separated by
  * ', ' and surrounded by a matching pair of brackets '[' and ']'.
  * Use the %rawarray% argument for arrays which elements already are json values (including composites) 
  * themselves and %array% for arrays of weidu strings (and ints) which need converting to json before
  * formatting.
  */	
DEFINE_PATCH_FUNCTION json_array
	INT_VAR 
		/** If specified, only that many first elements of the array are included.
		  * Useful when other functions return non-empty arrays with explicitly specified
		  * zero size due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of an array construct containing the json elements to include. */
		rawarray = ~~
		/** Name of an array construct containing the values to include. 
		  * All elements will be converted to json as per json_atom. */
		array = ~~
	RET 
		/** A string containing a json array with the given elements. */	
		res
	BEGIN
		INNER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_array 
				INT_VAR offset = 0 size = size
				STR_VAR rawarray = EVAL ~%rawarray%~ array = EVAL ~%array%~
			END
		END
	END



/** Formats an associative array as a json object. The keys are names of the fields of
  * the object while their associated values the field values. The exacTheir
  * handling depends on which of the input parameters %rawfields%, %fields% and %dict% is specified. 
  * Any parameter, when present, must contain a name of a json weidu construct. The keys of %rawfields%
  * must be valid json strings ready to include verbatim in the result; the keys of %fields% and %dict%
  * are treated as string values and formatted as json strings as per json_string before writing.
  * The values of %rawfields% and %fields% must be valid json values (including composites), while
  * the values of %dict% are treated as weidu values (strings or ints) and formatted accordingly:
  * if an element is a valid integer, it is written as a number. Otherwise it is formatted as a json
  * string value.
  */  
DEFINE_ACTION_FUNCTION json_object
	INT_VAR 
		/** If specified, only that many first fields from the array are included.
		  * Useful when another function returns a non-empty array with explicitly 
		  * specified zero length due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of a weidu array containing key-value pairs matching field names (as valid json strings)
		  * with their json values. */
		rawfields = ~~
		/** Name of a weidu array containing key-value pairs matching field names (as weidu strings)
		  * with their json values. */
		fields = ~~
		/** Name of a weidu array containing key-value pairs matching fields names (as weidu strings)
		  * with their weidu values. */
		dict = ~~
	RET 
		/** Returned string representation of the formatted json object. */
		res	
	BEGIN
		OUTER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_object
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawfields = EVAL ~%rawfields%~
					fields = EVAL ~%fields%~
					dict = EVAL ~%dict%~
			END
		END
	END
	
	
	
/** Formats an associative array as a json object. The keys are names of the fields of
  * the object while their associated values the field values. The exacTheir
  * handling depends on which of the input parameters %rawfields%, %fields% and %dict% is specified. 
  * Any parameter, when present, must contain a name of a json weidu construct. The keys of %rawfields%
  * must be valid json strings ready to include verbatim in the result; the keys of %fields% and %dict%
  * are treated as string values and formatted as json strings as per json_string before writing.
  * The values of %rawfields% and %fields% must be valid json values (including composites), while
  * the values of %dict% are treated as weidu values (strings or ints) and formatted accordingly:
  * if an element is a valid integer, it is written as a number. Otherwise it is formatted as a json
  * string value.
  */  
DEFINE_PATCH_FUNCTION json_object
	INT_VAR 
		/** If specified, only that many first fields from the array are included.
		  * Useful when another function returns a non-empty array with explicitly 
		  * specified zero length due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of a weidu array containing key-value pairs matching field names (as valid json strings)
		  * with their json values. */
		rawfields = ~~
		/** Name of a weidu array containing key-value pairs matching field names (as weidu strings)
		  * with their json values. */
		fields = ~~
		/** Name of a weidu array containing key-value pairs matching fields names (as weidu strings)
		  * with their weidu values. */
		dict = ~~
	RET 
		/** Returned string representation of the formatted json object. */
		res	
	BEGIN
		INNER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_object
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawfields = EVAL ~%rawfields%~
					fields = EVAL ~%fields%~
					dict = EVAL ~%dict%~
			END
		END
	END






	
/*************************************************************************************
 ********************    Internal json parsing functions          ********************
 *************************************************************************************/ 
	
	

DEFINE_PATCH_MACRO skip_whitespace_before_json BEGIN
	PATCH_IF offset < 0 THEN BEGIN
		SET offset = cursor
	END
	SET skipped = 0
	LPF skip_buffer_whitespace INT_VAR offset = offset RET start = offset srclength peek END
END



DEFINE_PATCH_FUNCTION skip_json_null 
	INT_VAR offset = 0 - 1
	RET offset skipped		
	BEGIN
		LPM skip_whitespace_before_json
		
		PATCH_IF start < srclength - 4 THEN BEGIN
			READ_ASCII start val (4)
			PATCH_IF ~%val%~ STR_EQ ~null~ THEN BEGIN
				SET skipped = start + 4 - offset
				SET offset = start + 4 
			END
		END
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_boolean
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json

		PATCH_IF start <= srclength - 5 AND ~%peek%~ STR_EQ ~f~ THEN BEGIN
			READ_ASCII start val (5)
			PATCH_IF ~%val%~ STR_EQ ~false~ THEN BEGIN
				SET skipped = start + 5 - offset
				SET offset = start + 5
			END
		END ELSE PATCH_IF start <= srclength - 4 AND ~%peek%~ STR_EQ ~t~ THEN BEGIN
			READ_ASCII start val (4)
			PATCH_IF ~%val%~ STR_EQ ~true~ THEN BEGIN
				SET skipped = start + 4 - offset
				SET offset = start + 4
			END
		END 
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_number
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		
		TEXT_SPRINT digits ~0123456789~

		PATCH_MATCH ~%peek%~ WITH 
			~0~ BEGIN
				SET i = start + 1
				PATCH_IF i < srclength THEN BEGIN				
					READ_ASCII i peek (1)
					PATCH_MATCH ~%peek%~ WITH
						~x~ ~X~ BEGIN //hexadecimal value
							TEXT_SPRINT digits ~0123456789AaBbCcDdEeFf~
							SET i += 1						
							SET start = i
						END
						~o~ ~O~ BEGIN //octal value
							TEXT_SPRINT digits ~01234567~
							SET i += 1
							SET start = i
						END
						~b~ ~B~ BEGIN //binary value
							TEXT_SPRINT digits ~01~
							SET i += 1
							SET start = i
						END
						DEFAULT //decimal value							
					END
					READ_ASCII i peek (1)
				END
			END
			~+~ ~-~ BEGIN
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset peek END
				SET i = start
			END
//			~o~ BEGIN
//				TEXT_SPRINT digits ~01234567~
//				SET i = start + 1				
//			END
			DEFAULT
				SET i = start
		END

		PATCH_IF i < srclength THEN BEGIN		
			SET continue = INDEX(CASE_SENSITIVE EXACT_MATCH ~%peek%~ ~%digits%~) >= 0
			WHILE i < srclength - 1 AND continue BEGIN
				SET i += 1
				READ_ASCII i peek (1)				
				SET continue = INDEX(CASE_SENSITIVE EXACT_MATCH ~%peek%~ ~%digits%~) >= 0

			END
			PATCH_IF continue THEN BEGIN
				SET i += 1
			END
		END

		PATCH_IF i > start THEN BEGIN
			SET skipped = i - offset
			SET offset = i
		END		
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_string
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		
		PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN
			SET i = start + 1
			TEXT_SPRINT peek ~~
			
			WHILE (i < srclength AND NOT ~%peek%~ STR_EQ ~"~) BEGIN //let's find the closing '"'					
				READ_ASCII i peek (1)
				SET j = i //advance over all following '\' checking parity
				WHILE (j < srclength - 1 AND ~%peek%~ STR_EQ ~\~) BEGIN
					SET j += 1
					READ_ASCII j peek (1)
				END
				PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN //check if it's escaped
					PATCH_IF (j - i) MODULO 2 = 1 THEN BEGIN //escaped
						TEXT_SPRINT peek ~~ //'hide' the '"'
					END
				END
				SET i = j + 1
			END //%i% - 1 is the index of closing '"' or i=srclength => no closing '"'
			
			PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN //yay!
				SET skipped = i - offset
				SET offset = i
			END
		END	
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_array
	INT_VAR offset = 0 - 1
	RET offset skipped size
	BEGIN
		LPM skip_whitespace_before_json			
		SET size = 0
		
		PATCH_IF ~%peek%~ STR_EQ ~[~ THEN BEGIN
			LPF skip_json INT_VAR offset = start + 1 RET i = offset skipped END
			LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
			PATCH_IF skipped THEN BEGIN
				SET size += 1
			END
			WHILE skipped AND ~%peek%~ STR_EQ ~,~ BEGIN
				LPF skip_json INT_VAR offset = i + 1 RET i = offset skipped END
				PATCH_IF skipped THEN BEGIN
					LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
					SET size += 1
				END 					
			END
			
			PATCH_IF ~%peek%~ STR_EQ ~]~ THEN BEGIN
				SET skipped = i + 1 - offset 
				SET offset = i + 1
			END ELSE BEGIN
				SET skipped = 0
				SET size = 0
			END
		END
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_object_field 
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPF skip_json_string INT_VAR offset = offset RET i = offset skipped END
		LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
			
		PATCH_IF skipped AND ~%peek%~ STR_EQ ~:~ THEN BEGIN
			LPF skip_json INT_VAR offset = i + 1 RET i = offset skipped END
			
			PATCH_IF skipped THEN BEGIN
				SET skipped = i - offset
				SET offset = i
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_object
	INT_VAR offset = 0 - 1
	RET offset skipped size
	BEGIN
		LPM skip_whitespace_before_json
		SET size = 0
		
		PATCH_IF ~%peek%~ STR_EQ ~{~ THEN BEGIN
			LPF skip_json_object_field INT_VAR offset = start + 1 RET i = offset skipped END
			LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
			PATCH_IF skipped THEN BEGIN
				SET size += 1
			END
			
			WHILE skipped AND ~%peek%~ STR_EQ ~,~ BEGIN
				LPF skip_json_object_field INT_VAR offset = i + 1 RET i = offset skipped END
				PATCH_IF skipped THEN BEGIN
					LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
					SET size += 1
				END
			END
			
			PATCH_IF ~%peek%~ STR_EQ ~}~ THEN BEGIN
				SET skipped = i + 1 - offset
				SET offset = i + 1
			END ELSE BEGIN
				SET skipped = 0
			END
		END
	END



DEFINE_PATCH_FUNCTION skip_json
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		PATCH_MATCH ~%peek%~ WITH
			~"~ BEGIN
				LPF skip_json_string INT_VAR offset = start RET offset skipped END
			END
			~\[~ BEGIN
				LPF skip_json_array INT_VAR offset = start RET offset skipped END
			END
			~{~ BEGIN
				LPF skip_json_object INT_VAR offset = start RET offset skipped END
			END
			~t~ ~f~ BEGIN
				LPF skip_json_boolean INT_VAR offset = start RET offset skipped END
			END
			~n~ BEGIN
				LPF skip_json_null INT_VAR offset = start RET offset skipped END
			END
			DEFAULT 
				LPF skip_json_number INT_VAR offset = start RET offset skipped END
		END
	END

 	
	
	
		
	
/*************************************************************************************
 ********************    Reading json from the patch buffer       ********************
 *************************************************************************************/ 



DEFINE_PATCH_MACRO read_skipped_json BEGIN
	PATCH_IF skipped THEN BEGIN
		READ_ASCII start json (end - start)
		SET offset = end
	END ELSE BEGIN
		LPF report_invalid_json 
			INT_VAR at = start
			STR_VAR msg = ~Invalid json or unexpected data type~ 
		END
	END
END



/** Reads the json boolean value following the given offset in the current patch buffer.
  * Any leading whitespace is ignored. If the following content is not a 'true' or 'false' string,
  * or the offset is larger than buffer length, an error is raised.
  */
DEFINE_PATCH_FUNCTION read_json_boolean
	INT_VAR	
		/** Offset from which reading starts. If omitted, it defaults to zero. If negative,
		  * the value of %cursor% variable is used instead.
		  */
		offset = 0
	RET 
		/** Offset in the buffer immediately after the read data. */
		offset 
		/** Read boolean value as an integer: 0 for false, 1 for true. */
		res
	BEGIN
		LPM skip_whitespace_before_json
		LPF skip_json_boolean INT_VAR offset = start RET end = offset skipped END
		LPM read_skipped_json
		PATCH_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			SET res = 1
		END ELSE BEGIN
			SET res = 0
		END
	END




/** Reads the json number following the given offset in the current patch buffer.
  * Any leading whitespace is ignored. If the following content is not a valid integer,
  * or the offset is larger than buffer length, an error is raised.
  */ 
DEFINE_PATCH_FUNCTION read_json_number
	INT_VAR	
		/** Offset from which reading starts. If omitted, it defaults to zero. If negative,
		  * the value of %cursor% variable is used instead.
		  */
		offset = 0
	RET 
		/** Offset in the buffer immediately after the read data. */
		offset 
		/** Read integer value. */
		res
	BEGIN 
		LPM skip_whitespace_before_json
		LPF skip_json_number INT_VAR offset = start RET end = offset skipped END

		SET signum = 1
		PATCH_MATCH ~%peek%~ WITH
			~+~ BEGIN
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset END
			END
			~-~ BEGIN
				SET signum = 0 - 1
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset END
			END
			DEFAULT
		END
		LPM	read_skipped_json
		SET res = signum * json
	END
	
	

/** Reads the json string following the given offset in the current patch buffer.
  * Any leading whitespace is ignored. If the following content is not a valid string,
  * or the offset is larger than buffer length, an error is raised.
  * The string is returned exactly as read, without unquoting.
  */ 
DEFINE_PATCH_FUNCTION read_raw_json_string
	INT_VAR	
		/** Offset from which reading starts. If omitted, it defaults to zero. If negative,
		  * the value of %cursor% variable is used instead.
		  */
		offset = 0
	RET 
		/** Offset in the buffer immediately after the read data. */
		offset 
		/** Read string in the json format without any conversion. */
		res
	BEGIN 
		LPM skip_whitespace_before_json
		LPF skip_json_string INT_VAR offset = start RET offset skipped END
		PATCH_IF NOT skipped THEN BEGIN
			LPF report_invalid_json
				STR_VAR msg = EVAL ~rad_raw_json_string: expected a json string, got '%peek%'~
			END
		END
		READ_ASCII start res (offset - start)
	END
		
	
	
/** Reads the json string following the given offset in the current patch buffer.
  * Any leading whitespace is ignored. If the following content is not a valid string,
  * or the offset is larger than buffer length, an error is raised.
  * The string is converted to a standard weidu string by unquoting and unescaping.
  */ 
DEFINE_PATCH_FUNCTION read_json_string
	INT_VAR	
		/** Offset from which reading starts. If omitted, it defaults to zero. If negative,
		  * the value of %cursor% variable is used instead.
		  */
		offset = 0
	RET 
		/** Offset in the buffer immediately after the read data. */
		offset 
		/** Read string after conversion from json. */
		res
	BEGIN 
		LPM skip_whitespace_before_json

		PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN
			SET size = 0
			SET i = start + 1
			TEXT_SPRINT peek ~~
			
			WHILE (i < srclength AND NOT ~%peek%~ STR_EQ ~"~) BEGIN //let's find the closing '"'					
				READ_ASCII i peek (1)
				SET j = i //advance over all following '\' checking parity
				WHILE (j < srclength - 1 AND ~%peek%~ STR_EQ ~\~) BEGIN
					PATCH_IF (j - i) REM 2 = 1 THEN BEGIN
						TEXT_SPRINT $chars(~%size%~) ~%peek%~
						SET size += 1
					END
					SET j += 1
					READ_ASCII j peek (1)
				END
				PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN //check if it's escaped
					PATCH_IF (j - i) REM 2 = 1 THEN BEGIN //escaped
						TEXT_SPRINT peek ~~ //'hide' the '"'
						TEXT_SPRINT $chars(~%size%~) ~"~
						SET size += 1
					END
				END ELSE BEGIN
					TEXT_SPRINT $chars(~%size%~) ~%peek%~
					SET size += 1
				END
				SET i = j + 1
			END //%i% - 1 is the index of closing '"' or i=srclength => no closing '"'
			
			PATCH_IF ~%peek%~ STR_EQ ~"~ THEN BEGIN //yay!
				SET offset = i
				LPF concat STR_VAR array = ~chars~ RET res END
			END ELSE BEGIN
				LPF report_invalid_json 
					INT_VAR at = i 
					STR_VAR msg = EVAL ~read_json_string: no closing '"' for opening '"'~
				END
			END
		END	ELSE BEGIN
			LPF report_invalid_json
				INT_VAR at = start
				STR_VAR msg = EVAL ~read_json_string: expected opening '"', got: '%peek%'~
			END
		END

	END
	
	

/** Reads the json value following the given offset in the current patch buffer.
  * Any leading whitespace is ignored. The value must be either a boolean, integer or a string;
  * otherwise an error is raised. If the value is a boolean, it is returned as either zero or one.
  * Integral numbers are returned as integers, while strings are unquoted and unescaped to their
  * 'normal' selves.
  */ 
DEFINE_PATCH_FUNCTION read_json_atom
	INT_VAR	
		/** Offset from which reading starts. If omitted, it defaults to zero. If negative,
		  * the value of %cursor% variable is used instead.
		  */
		offset = 0
	RET 
		/** Offset in the buffer immediately after the read data. */
		offset 
		/** Read value after conversion from json. */
		res
	BEGIN
		LPM skip_whitespace_before_json
		PATCH_MATCH ~%peek%~ WITH
			~"~ BEGIN
				LPF read_json_string INT_VAR offset = start RET offset res END
			END
			~t~ ~f~ BEGIN
				LPF read_json_boolean INT_VAR offset = start RET offset res END
			END
			~[+-0123456789]~ BEGIN
				LPF read_json_number INT_VAR offset = start RET offset res END
			END
			DEFAULT 
				LPF report_invalid_json
					STR_VAR msg = EVAL ~read_json_atom: '%peek%' is an invalid start of a json variable~
				END
		END
	END
	
	

/** Reads a json array from the patched buffer and returns it as a WeiDU array which elements
  * are intact json values read from the buffer.
  */  
DEFINE_PATCH_FUNCTION read_raw_json_array
	INT_VAR 
		/** The index at which the reading starts. The first non-white character after %offset%
		  * must be the array opening bracket '['. */
		offset = 0 
	RET 
		/** The position in the buffer immediately after the closing bracket ']' of the read array. */
		offset 
		/** Number of elements in the read array. If zero, the returned array will contain a synthetic
		  * element which was not part of the input. */
		size
	RET_ARRAY 
		/** An array (indexed by natural numbers starting with zero) containing all json elements
		  * of the read array. The elements are stored as unmodified json strings. If the input array
		  * is empty, %res% will contain a single synthetic element mandated by WeiDU. 
		  * Always check %size% before accessing the array. */
		res
	BEGIN
		CLEAR_ARRAY res
		LPM skip_whitespace_before_json			
		SET size = 0
		
		PATCH_IF ~%peek%~ STR_EQ ~[~ THEN BEGIN
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset peek END
			
			PATCH_IF NOT ~%peek%~ STR_EQ ~]~ THEN BEGIN
				LPF read_json INT_VAR offset = offset RET offset json END
				TEXT_SPRINT $res(~0~) ~%json%~ 
				SET size += 1
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				
				WHILE ~%peek%~ STR_EQ ~,~ BEGIN
					LPF read_json INT_VAR offset = offset + 1 RET offset json END
					TEXT_SPRINT $res(~%size%~) ~%json%~
					SET size += 1
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				END
			END

			PATCH_IF NOT ~%peek%~ STR_EQ ~]~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~read_raw_json_array: expected ',' or ']', got '%peek%' at #%offset% following '%prefix%'.~
			END
			SET offset += 1
			
			PATCH_IF size = 0 THEN BEGIN
				TEXT_SPRINT $res(~~) ~<empty array; check size before accessing>~
			END
		END ELSE BEGIN
			LPF report_invalid_json
				STR_VAR msg = EVAL ~read_raw_json_array: expected '[', got '%peek%'~
			END
		END
		
	END
	
	

/** Reads a json array from the patched buffer and returns it as a WeiDU array containing
  * converted json elements of the input array. All string values become unquoted and unescaped,
  * boolean values are converted to integers '0' and '1'. If the input array contains an element
  * other than integers, strings and booleans, an error is raised.
  */  	
DEFINE_PATCH_FUNCTION read_json_array
	INT_VAR 
		/** The index at which the reading starts. The first non-white character after %offset%
		  * must be the array opening bracket '['. */
		offset = 0
	RET 
		/** The position in the buffer immediately after the closing bracket ']' of the read array. */
		offset 
		/** Number of elements in the read array. If zero, the returned array will contain a synthetic
		  * element which was not part of the input. */
		size
	RET_ARRAY 
		/** An array (indexed by natural numbers starting with zero) containing all elements
		  * of the read array. The elements are converted from the json format to standard
		  * WeiDU values before storing. If the input array is empty, %res% will contain 
		  * a single synthetic element mandated by WeiDU. Always check %size% before accessing the array. 
		  */
		res
	BEGIN
		LPF read_raw_json_array INT_VAR offset = offset RET offset size RET_ARRAY res END
		FOR (i = 0; i < size; ++i) BEGIN
			TEXT_SPRINT json $res(~%i%~)
			INNER_PATCH ~%json%~ BEGIN
				LPF read_json_atom INT_VAR offset = 0 RET val = res END
			END
			TEXT_SPRINT $res(~%i%~) ~%val%~
		END
	END
	
	

/** Reads the element at the specified index of a json array in the patch buffer. 
  * If the input array is shorter than required, the provided default value is returned instead.
  */
DEFINE_PATCH_FUNCTION read_json_array_element
	INT_VAR 
		/** The offset in the patch buffer before the input array. The first following 
		  * non-white character must be the opening bracket '['. */
		offset = 0
		/** The index of the requested element, starting with zero. */
		idx = 0
	STR_VAR
		/** The value to return if the input array's length is lesser than %idx%. Defaults to ~~. */
		default = ~~
	RET	
		/** The %idx%-th element of the input array as unconverted json. */
		res
	BEGIN
		PATCH_IF idx < 0 THEN BEGIN
			TEXT_SPRINT res ~%default%~
		END ELSE BEGIN
			LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
			
			PATCH_IF NOT ~%peek%~ STR_EQ ~[~ THEN BEGIN
				LPF report_invalid_json
					STR_VAR msg = EVAL ~json_array_element: expected '[' but got '%peek%'~
				END
			END
			
		
			LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET start = offset peek END
			SET skipped = 0
			
			WHILE idx >= 0 AND NOT (~%peek%~ STR_EQ ~]~) BEGIN
				PATCH_IF skipped THEN BEGIN //not the first iteration
					PATCH_IF NOT ~%peek%~ STR_EQ ~,~ THEN BEGIN
						LPF report_invalid_json
							STR_VAR msg = EVAL ~json_array_element: expected ',' but got '%peek%'~
						END
					END
					LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET start = offset END
				END						

				LPF skip_json INT_VAR offset = start RET end = offset skipped END
				
				PATCH_IF NOT skipped THEN BEGIN
					LPF report_invalid_json
						INT_VAR at = start
						STR_VAR msg = EVAL ~json_array_element: invalid json element~
					END
				END
				LPF skip_buffer_whitespace INT_VAR offset = end RET offset peek END
				SET idx -= 1
			END
			PATCH_IF idx < 0 THEN BEGIN
				READ_ASCII start res (end - start)
			END ELSE BEGIN
				TEXT_SPRINT res ~%default%~
			END
		END	

	END
	
	

/** Reads a key-value pair of a json object from the patch buffer. Expects to find
  * data in the format of '"key":<json_value>' with optional whitespace around the two values. 
  * If read data does not conform to that format an error is raised.
  */
DEFINE_PATCH_FUNCTION read_raw_json_object_field 
	INT_VAR 
		/** Offset in the buffer immediately before the json string serving as the key value, 
		  * Following whitespace is ignored. */
		offset = 0
	RET 
		/** The offset in the patch buffer immediately after the value of the read pair. */
		offset
		/** The json field (quoted in '"') being the key/field name of the read entry. */
		field 
		/** The json element being the value of the read entry. */
		value
	BEGIN
		LPF read_raw_json_string INT_VAR offset = offset RET  i = offset field = res END		
		LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset peek END
			
		PATCH_IF NOT ~%peek%~ STR_EQ ~:~ THEN BEGIN
			LPF report_invalid_json
				INT_VAR at = i
				STR_VAR msg = EVAL ~read_raw_json_object_field: missing ':' after field %field%~
			END
		END
		LPF read_json INT_VAR offset = i + 1 RET offset value = json END
	END
		


/** Reads a json object from the patch buffer in the raw (unconverted) json format.
  * The fields of the read object are returned as a WeiDU array which keys are json strings
  *	and values their associated json elements.
  */
DEFINE_PATCH_FUNCTION read_raw_json_object_fields
	INT_VAR 
		/** The offset in the patch buffer before the input array. The first following 
		  * non-white character must be the opening bracket '{'. */
		offset = 0
	RET 
		/** The offset in the patch buffer immediately after the closing bracket '}' of the read object. */
		offset 
		/** The number of fields (key-value entries) in the read json object. */
		size
	RET_ARRAY 
		/** An array which keys are (quoted) json strings and values their associated 
		  * json elements of any type. If the object is empty, the array will contain
		  * an artificial entry - check %size% before accessing. */
		res
	BEGIN
		CLEAR_ARRAY res
		LPM skip_whitespace_before_json
		SET size = 0
		PATCH_IF ~%peek%~ STR_EQ ~{~ THEN BEGIN
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset peek END
			
			PATCH_IF NOT ~%peek%~ STR_EQ ~}~ THEN BEGIN				
				LPF read_raw_json_object_field INT_VAR offset = offset RET offset field value END
				TEXT_SPRINT $res(~%field%~) ~%value%~
				SET size += 1
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				
				WHILE ~%peek%~ STR_EQ ~,~ BEGIN
					LPF read_raw_json_object_field INT_VAR offset = offset + 1 RET offset field value END
					TEXT_SPRINT $res(~%field%~) ~%value%~
					SET size += 1
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				END
			END

			PATCH_IF NOT ~%peek%~ STR_EQ ~}~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~read_raw_json_object_fields: expected ',' or '}'; got '%peek%' at #%offset% following '%prefix%'.~
			END 
			SET offset += 1
			
			PATCH_IF NOT size THEN BEGIN 
				TEXT_SPRINT $res(~""~) ~"<empty object; check size before accessing>"~
			END
		END ELSE BEGIN
			LPF report_invalid_json
				STR_VAR msg = EVAL  ~read_raw_json_object_fields: expected '{', got '%peek%'~
			END
		END
	END



/** Reads a json object from the patch buffer into a WeiDU array. The keys of the returned array
  * are converted (unquoted) strings given for field names. Their values are
  * unconverted json elements associated with the keys in the read object. 
  */
DEFINE_PATCH_FUNCTION read_json_object_fields
	INT_VAR 
		/** The offset in the patch buffer before the input array. The first following 
		  * non-white character must be the opening bracket '{'. */
		offset = 0
	RET 
		/** The offset in the patch buffer immediately after the closing bracket '}' of the read object. */
		offset 
		/** The number of fields (key-value entries) in the read json object. */
		size
	RET_ARRAY 
		/** An array which keys are (unquoted) strings being the key names and values 
		  * their associated json elements of any type. If the object is empty, 
		  * the array will contain an artificial entry - check %size% before accessing. */
		res
	BEGIN
		CLEAR_ARRAY res
		LPF read_raw_json_object_fields INT_VAR offset = offset RET offset size RET_ARRAY fields = res END
		PATCH_IF NOT size THEN BEGIN
			TEXT_SPRINT $res(~~) ~<empty object; check size before accessing>~
		END ELSE BEGIN
			PHP_EACH fields AS field => value BEGIN
				INNER_PATCH ~%field%~ BEGIN
					LPF read_json_string INT_VAR offset = 0 RET name = res END
				END
				TEXT_SPRINT $res(~%name%~) ~%value%~
			END
		END
	END
	
	
	
/** Reads a json object from the patch buffer into a WeiDU array. Both the keys and values
  * are converted from the json format to standard string variables: the keys are the names
  * of the fields. Their values are converted based on their type: strings become unquoted,
  * integer numbers are printed in the decimal format and boolean values are stored as either 
  * '0' or '1'. 
  */
DEFINE_PATCH_FUNCTION read_json_as_dict
	INT_VAR 
		/** The offset in the patch buffer before the input array. The first following 
		  * non-white character must be the opening bracket '{'. */
		offset = 0
	RET 
		/** The offset in the patch buffer immediately after the closing bracket '}' of the read object. */
		offset 
		/** The number of fields (key-value entries) in the read json object. */
		size
	RET_ARRAY 
		/** An array which keys are (unquoted) strings being the key names and values 
		  * are converted from json. If the object is empty, 
		  * the array will contain an artificial entry - check %size% before accessing. */
		res
	BEGIN
		CLEAR_ARRAY res
		LPF read_raw_json_object_fields INT_VAR offset = offset RET offset size RET_ARRAY fields = res END
		PATCH_IF NOT size THEN BEGIN
			TEXT_SPRINT $res(~~) ~<empty object; check size before accessing>~
		END ELSE BEGIN
			PHP_EACH fields AS field => json BEGIN
				INNER_PATCH ~%field%~ BEGIN
					LPF read_json_string INT_VAR offset = 0 RET name = res END
				END
				INNER_PATCH ~%json%~ BEGIN
					LPF read_json_atom INT_VAR offset = 0 RET value = res END
				END
				TEXT_SPRINT $res(~%name%~) ~%value%~
			END
		END
	END
	
	

/** Reads the json element following the given offset in the patch buffer.
  * The json value is returned as a string exactly equal to the read buffer fragment.
  */
DEFINE_PATCH_FUNCTION read_json	
	INT_VAR 
		/** The offset before the element to read. The first following non-white character
		  * must be the first character of the value to read. */
		offset = 0
	RET 
		/** The offset in the buffer immediately after the read element. */
		offset 
		/** Read json element. */
		json
	BEGIN
		LPM skip_whitespace_before_json
		LPF skip_json INT_VAR offset = start RET end = offset skipped END
		LPM read_skipped_json		
	END
	
	
	
	

/*************************************************************************************
 ********************         Json validation functions           ********************
 *************************************************************************************/ 



DEFINE_PATCH_MACRO skipped_json_was_whole_buffer BEGIN
	PATCH_IF NOT skipped THEN BEGIN
		SET is_json = 0
	END ELSE BEGIN
		LPF skip_buffer_whitespace INT_VAR offset = offset RET offset srclength END
		SET is_json = offset = srclength
	END
END



/** Sets the %is_null% return variable to zero if the passed %json% argument is not a valid json `null`
  * (does not equal 'null'), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_null INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_null = is_json
		END
	END
	
	
	
/** Sets the %is_null% return variable to zero if the passed %json% argument is not a valid json `null`
  * (does not equal 'null'), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_null STR_VAR json = EVAL ~%json%~ RET is_null END
		END
	END
	
	
	
/** Sets the %is_boolean% return variable to zero if the passed %json% argument is not a valid 
  * json boolean value ('true' or 'false'), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_boolean INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_boolean = is_json
		END
	END
	
	
	
/** Sets the %is_boolean% return variable to zero if the passed %json% argument is not a valid 
  * json boolean value ('true' or 'false'), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_boolean STR_VAR json = EVAL ~%json%~ RET is_boolean END
		END
	END
	
	

/** Sets the %is_int% return variable to zero if tne passed %json% argument is not a valid 
  * json number (IS_AN_INT is not true for the trimmed string), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_number
	STR_VAR json = ~~
	RET 
		is_int is_number
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_number INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_int = is_json
			SET is_number = is_int
		END
	END



/** Sets the %is_int% return variable to zero if the passed %json% argument is not a valid 
  * json number (IS_AN_INT is not true for the trimmed string), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_number
	STR_VAR json = ~~
	RET is_int
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_number STR_VAR json = EVAL ~%json%~ RET is_int END
		END
	END
	
	

/** Sets the %is_string% return variable to zero if the passed %json% argument is not a valid json string,
  * or to a non-zero value otherwise. The input %json% is trimmed of whitespace before validation.
  */
DEFINE_ACTION_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		OUTER_SET is_string = 1
		ACTION_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET is_string = 0
		END
	END
	
	

/** Sets the %is_string% return variable to zero if the passed %json% argument is not a valid json string,
  * or to a non-zero value otherwise. The input %json% is trimmed of whitespace before validation.
  */
DEFINE_PATCH_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		SET is_string = 1
		PATCH_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			SET is_string = 0
		END
	END
	
	

/** Sets the %is_atom% return variable to non-zero iff %json% is a valid json string, number, boolean
  * or null value. Leading and trailing whitespace is ignored for the purpose of this check.
  */
DEFINE_ACTION_FUNCTION is_json_atom
	STR_VAR json = ~~
	RET is_atom
	BEGIN
		OUTER_SET is_atom = NOT ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%\(null\|true\|false\)%WHITESPACE_RX%$~
		ACTION_IF NOT is_atom THEN BEGIN
			LAF is_json_number STR_VAR json = EVAL ~%json%~ RET is_atom = is_number END
			ACTION_IF NOT is_atom THEN BEGIN
				LAF is_json_string STR_VAR json = EVAL ~%json%~ RET is_atom = is_string END
			END
		END
	END
	
	
	
/** Sets the %is_atom% return variable to non-zero iff %json% is a valid json string, number, boolean
  * or null value. Leading and trailing whitespace is ignored for the purpose of this check.
  */
DEFINE_PATCH_FUNCTION is_json_atom
	STR_VAR json = ~~
	RET is_atom
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_atom STR_VAR json = EVAL ~%json%~ RET is_atom END
		END
	END
	
	
	
/** Sets the %is_array% return variable to zero if the passed %json% argument is not a valid json array,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_json_array
	STR_VAR json = ~~
	RET is_array
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_array INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_array = is_json
		END
	END
	
	

/** Sets the %is_array% return variable to zero if the passed %json% argument is not a valid json array,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_json_array
	STR_VAR json = ~~
	RET is_array
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_array STR_VAR json = EVAL ~%json%~ RET is_array END
		END
	END
	
	
	
/** Sets the %is_object% return variable to zero if the passed %json% argument is not a valid json object,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_object INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_object = is_json
		END
	END



/** Sets the %is_object% return variable to zero if the passed %json% argument is not a valid json object,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_object STR_VAR json = EVAL ~%json%~ RET is_object END
		END
	END
	
	
	
/** Sets the %is_object% return variable to zero if the passed %json% argument is not 
  * a correctly formatted Json, or to a non-zero value otherwise. Any leading or trailing 
  * whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
		END
	END



/** Sets the %is_object% return variable to zero if the passed %json% argument is not 
  * a correctly formatted Json, or to a non-zero value otherwise. Any leading or trailing 
  * whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		INNER_ACTION BEGIN
			LAF is_valid_json STR_VAR json = EVAL ~%json%~ RET is_json END
		END
	END	
	
	
		
/** Fails if %json% is not a valid Json, no-op otherwise. */
DEFINE_ACTION_FUNCTION validate_json
	STR_VAR 
		json = ~~
		logprefix = ~~
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			PATCH_IF NOT is_json THEN BEGIN
				PATCH_FAIL ~%logprefix%invalid json <<%json%>>.~
			END
		END
	END
	
	
	
/** Fails if %json% is not a valid Json, no-op otherwise. */	
DEFINE_PATCH_FUNCTION validate_json
	STR_VAR 
		json = ~~ 
		logprefix = ~~
	BEGIN
		INNER_ACTION BEGIN
			LAF validate_json 
				STR_VAR logprefix = EVAL ~%logprefix%~ json = EVAL ~%json%~ 
			END
		END
	END


	
	
	

/*************************************************************************************
 ********************     Converting json to weidu variables      ********************
 *************************************************************************************/ 




DEFINE_PATCH_MACRO read_json_must_be_whole_buffer BEGIN
	PATCH_IF NOT offset THEN BEGIN
		LPF next_buffer_token 
			INT_VAR offset = 0
			STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
			RET json = token END		
		PATCH_FAIL ~Invalid json or unexpected data type: <<%json%>>.~
	END ELSE BEGIN
		LPF skip_buffer_whitespace INT_VAR offset = offset RET offset srclength END
		
		PATCH_IF offset != srclength THEN BEGIN
			LPF next_buffer_token 
				INT_VAR offset = offset
				STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
				RET json = token END		
			LPF report_invalid_json STR_VAR msg = EVAL ~Expected EOF but got: <<%json%>>~ END
		END
	END
END



/** Converts a json boolean (one of 'true'/'false' strings) into a weidu integer. */	
DEFINE_ACTION_FUNCTION json_boolean_value
	STR_VAR 
		/** Input json representation of the boolean. */
		json = ~~
	RET 
		/** 1 or 0, depending on the read value. */
		res 
	BEGIN
		ACTION_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF ~%json%~ STR_EQ ~false~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE BEGIN
			FAIL ~Expected a Json Boolean but got: <<%json%>>.~
		END
	END
	
	
	
/** Converts a json boolean (one of 'true'/'false' strings) into a weidu integer. */	
DEFINE_PATCH_FUNCTION json_boolean_value
	STR_VAR 
		/** Input json representation of the boolean. */
		json = ~~
	RET 
		/** 1 or 0, depending on the read value. */
		res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_boolean_value STR_VAR json = EVAL ~%json%~ RET res END
		END
	END
	
	
	
/** Converts a json boolean (one of 'true'/'false' strings) into a weidu integer. 
  * Any leading whitespace in the input string is ignored.
  */	
DEFINE_ACTION_FUNCTION json_to_boolean
	STR_VAR 
		/** Input json representation of the boolean. */
		json = ~~
	RET 
		/** 1 or 0, depending on the read value. */
		res 
	BEGIN
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%true%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%false%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE BEGIN
			FAIL ~Expected a Json Boolean but got: <<%json%>>.~
		END
	END
		
		
		
/** Converts a json boolean (one of 'true'/'false' strings) into a weidu integer. 
  * Any leading whitespace in the input string is ignored.
  */	
DEFINE_PATCH_FUNCTION json_to_boolean
	STR_VAR 
		/** Input json representation of the boolean. */
		json = ~~
	RET 
		/** 1 or 0, depending on the read value. */
		res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_boolean STR_VAR json = EVAL ~%json%~ RET res END
		END
	END



/** Converts a json number into a weidu integer variable using the autoconversion from string. 
  * Input json must be a valid integer in a format accepte by weidu. */
DEFINE_ACTION_FUNCTION json_number_value
	STR_VAR 
		/** A string with the value of the returned number. */
		json = ~~
	RET 
		/** Parsed integer value of %json%. */
		res
	BEGIN 
		ACTION_IF IS_AN_INT ~%json%~ THEN BEGIN
			OUTER_SET res = ~%json%~ 
		END ELSE BEGIN
			FAIL ~json_number_value: not a number <<%json%>>~
		END
	END

	
	
/** Converts a json number into a weidu integer variable using the autoconversion from string. 
  * Input json must be a valid integer in a format accepte by weidu. */
DEFINE_PATCH_FUNCTION json_number_value
	STR_VAR 
		/** A string with the value of the returned number. */
		json = ~~
	RET 
		/** Parsed integer value of %json%. */
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_number_value STR_VAR json = EVAL ~%json%~ RET res END
		END
	END



/** Converts a json number into a weidu integer variable. The number can be in any
  * valid json format (octal, hex, decimal, positive or negative). 
  * Any leading whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION json_to_int
	STR_VAR 
		/** A string with the value of the returned number. */
		json = ~~
	RET 
		/** Parsed integer value of %json%. */
		res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_number INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
/** Converts a json number into a weidu integer variable. The number can be in any
  * valid json format (octal, hex, decimal, positive or negative). 
  * Any leading whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION json_to_int
	STR_VAR 
		/** A string with the value of the returned number. */
		json = ~~
	RET 
		/** Parsed integer value of %json%. */
		res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_number INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	

	
DEFINE_ACTION_FUNCTION json_string_value 
	STR_VAR json = ~~
	RET res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_PATCH_FUNCTION json_string_value
	STR_VAR json = ~~
	RET res 
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END

	

DEFINE_ACTION_FUNCTION json_value
	STR_VAR json = ~~
	RET res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_atom INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_PATCH_FUNCTION json_value
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_atom INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_ACTION_FUNCTION json_to_raw_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_to_raw_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END





	
DEFINE_ACTION_FUNCTION raw_json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION raw_json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END


	
DEFINE_ACTION_FUNCTION json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_dict
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_as_dict INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_dict
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_as_dict INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END



/*************************************************************************************
 ********************    Extracting individual values from Json   ********************
 *************************************************************************************/ 



/** Returns the size (number of elements) of the given json array. */
DEFINE_ACTION_FUNCTION json_array_size
	STR_VAR json = ~~
	RET size
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			SET offset = 0
			LPF skip_json_array INT_VAR offset = 0 RET skipped = offset size END
			LPM skipped_json_was_whole_buffer
		END
	END
	
	

/** Returns the size (number of elements) of the given json array. */
DEFINE_PATCH_FUNCTION json_array_size
	STR_VAR json = ~~
	RET size
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			SET offset = 0
			LPF skip_json_array INT_VAR offset = 0 RET skipped = offset size END
			LPM skipped_json_was_whole_buffer
		END
	END



/** Returns the element at the specified index in the array. The element is returned as json. */	
DEFINE_ACTION_FUNCTION json_array_element
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN	
		ACTION_IF idx < 0 THEN BEGIN
			OUTER_TEXT_SPRINT res ~%default%~
		END ELSE BEGIN
			OUTER_PATCH ~%json%~ BEGIN
				LPF read_json_array_element 
					INT_VAR idx = idx offset = 0 
					STR_VAR default = EVAL ~%default%~
					RET res END
			END
		END
	END
	
	
	
/** Returns the element at the specified index in the array. The element is returned as json. */	
DEFINE_PATCH_FUNCTION json_array_element
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		PATCH_IF idx < 0 THEN BEGIN
			TEXT_SPRINT res ~%default%~
		END ELSE BEGIN
			INNER_PATCH ~%json%~ BEGIN
				LPF read_json_array_element 
					INT_VAR idx = idx offset = 0 
					STR_VAR default = EVAL ~%default%~
					RET res END
			END
		END
	END
		
	

/** Returns the element at the specified index in the array. 
  * The json element is converted to a weidu variable before returning:
  *  - strings are unescaped and without the extra '"' chars;
  *  - numbers are returned verbatim (formatted as strings);
  *  - boolean values are converted to ~0~ or ~1~;
  *  - other elements can't be converted and result in a failure.
. */	
DEFINE_ACTION_FUNCTION json_array_at
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		ACTION_IF idx < 0 THEN BEGIN
			FAIL ~Index out of bounds: %idx% element of %json%~
		END
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_array_element INT_VAR idx = idx offset = 0 RET element = res END
		END
		OUTER_PATCH ~%element%~ BEGIN
			PATCH_IF NOT BUFFER_LENGTH THEN BEGIN
				PATCH_FAIL ~json_array_at: index %idx% out of bounds or invalid json array <<%json%>>.~
			END
			LPF read_json_atom INT_VAR offset = 0 RET res END
		END
	END
	
		
	
/** Returns the element at the specified index in the array. 
  * The json element is converted to a weidu variable before returning:
  *  - strings are unescaped and without the extra '"' chars;
  *  - numbers are returned verbatim (formatted as strings);
  *  - boolean values are converted to ~0~ or ~1~;
  *  - other elements can't be converted and result in a failure.
. */	
DEFINE_PATCH_FUNCTION json_array_at
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_at INT_VAR idx = idx STR_VAR json = EVAL ~%json%~ RET res END
		END
	END


	
DEFINE_ACTION_FUNCTION json_raw_field	
	STR_VAR
		json = ~~
		field = ~~
		rawfield = ~~
		default = ~~
	RET	res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			PATCH_IF ~%rawfield%~ STR_EQ ~~ THEN BEGIN
				LPF json_string STR_VAR string = EVAL ~%field%~ RET rawfield = res END
			END

			LPF skip_buffer_whitespace INT_VAR offset = 0 RET offset peek END
			
			PATCH_IF NOT ~%peek%~ STR_EQ ~{~ THEN BEGIN
				PATCH_FAIL ~json_raw_field: expected '{' but got '%peek%' at #%offset% in json <<%json%>>.~
			END
			
			LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET offset peek END
			TEXT_SPRINT property ~~

			WHILE NOT (~%peek%~ STR_EQ ~}~ OR ~%property%~ STR_EQ ~%rawfield%~) BEGIN
				PATCH_IF NOT ~%property%~ STR_EQ ~~ THEN BEGIN //not the first iteration
					PATCH_IF NOT ~%peek%~ STR_EQ ~,~ THEN BEGIN
						PATCH_FAIL ~json_raw_field: expected ',' but got '%peek%' at #%offset% in <<%json%>>.~
					END
					SET offset += 1
				END
				
				LPF read_raw_json_object_field 
					INT_VAR offset = offset 
					RET property = field res = value offset END
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
			END
			
			PATCH_IF NOT ~%property%~ STR_EQ ~%rawfield%~ THEN BEGIN
				TEXT_SPRINT res ~%default%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_raw_field
	STR_VAR
		json = ~~
		rawfield = ~~
		field = ~~
		default = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_raw_field 
				STR_VAR 
					json = EVAL ~%json%~ 
					rawfield = EVAL ~%rawfield%~
					field = EVAL ~%field%~ 
					default = EVAL ~%default%~
				RET res END
		END
	END



DEFINE_ACTION_FUNCTION json_field
	STR_VAR
		json = ~~
		field = ~~
	RET res
	BEGIN
		LAF json_raw_field 
			STR_VAR json = EVAL ~%json%~ field = EVAL ~%field%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~json_field: no field named '%field%' in object '%json%'~
		END
		LAF json_value STR_VAR json = EVAL ~%res%~ RET res END
	END
	

	
DEFINE_PATCH_FUNCTION json_field	
	STR_VAR
		json = ~~
		field = ~~
	RET res
	BEGIN //todo: all these methods could better pass the json argument as patch buffer
		INNER_ACTION BEGIN
			LAF json_field 
				STR_VAR json = EVAL ~%json%~ field = EVAL ~%field%~
				RET res END
		END
	END






DEFINE_ACTION_FUNCTION get_json
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		OUTER_TEXT_SPRINT res ~~
		//todo: use a simpler function for first black char without evaluating json
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%{~ THEN BEGIN //json object			
			LAF json_object_fields 
				STR_VAR json = EVAL ~%json%~ 
				RET size 
				RET_ARRAY fields = res END		

			ACTION_IF size THEN BEGIN
				OUTER_TEXT_SPRINT prefix ~%property%~
				OUTER_TEXT_SPRINT suffix ~~
				OUTER_TEXT_SPRINT separator ~~
				OUTER_SET reduced = 1
				//iterate over property prefixes of %property% in decreasing length in search for a matching property
				OUTER_WHILE reduced BEGIN 
					OUTER_TEXT_SPRINT value ~~
					//we search in a loop instead of using VARIABLE_IS_SET because it doesn't work
					//with dots and other special characters in key names.
					ACTION_PHP_EACH fields AS field => child BEGIN
						ACTION_IF ~%field%~ STR_EQ ~%prefix%~ THEN BEGIN
							OUTER_TEXT_SPRINT value ~%child%~
						END
					END
					ACTION_IF NOT ~%value%~ STR_EQ ~~ THEN BEGIN
						LAF get_json //continue recursion with the suffix as the property
							STR_VAR json = EVAL ~%value%~ property = EVAL ~%suffix%~
							RET res END
						OUTER_SET reduced = 0 //terminate the loop
					
					END ELSE BEGIN //check the next prefix property
						OUTER_SET reduced = 0
						//if %prefix% ends with ~[<idx>]~ move the indexing to the front of %suffix% 
						OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
							REPLACE_EVALUATE CASE_SENSITIVE ~\[\([0-9]+\)\]$~ BEGIN
								TEXT_SPRINT suffix ~[%MATCH1%]%separator%%suffix%~
								TEXT_SPRINT separator ~~
								SET reduced = 1
							END ~~
						END
						//if %prefix% ends with ~.<property>~ move that simple property to the front of %suffix%
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\%JSON_PROPERTY_SEPARATOR%\([^%JSON_PROPERTY_SEPARATOR%]*\)$~ BEGIN
									TEXT_SPRINT suffix ~%MATCH1%%separator%%suffix%~
									TEXT_SPRINT separator ~%JSON_PROPERTY_SEPARATOR%~ //the dot we swallowed in the match
									SET reduced = 1
								END ~~
							END
						END
						ACTION_IF NOT reduced THEN BEGIN
							//if %prefix% is non-empty, check for a ~~ property next, moving %prefix% to %suffix%
							ACTION_IF NOT ~%prefix%~ STR_EQ ~~ THEN BEGIN //%property% is a simple property
								OUTER_TEXT_SPRINT suffix ~%prefix%%separator%%suffix%~
								OUTER_TEXT_SPRINT prefix ~~						
								OUTER_SET reduced = 1
								
							//If %prefix% starts with '.' check for a property without that leading dot	
							END ELSE ACTION_IF ~%separator%~ STR_EQ ~%JSON_PROPERTY_SEPARATOR%~ BEGIN
								OUTER_TEXT_SPRINT prefix ~%suffix%~
								OUTER_TEXT_SPRINT suffix ~~
								OUTER_TEXT_SPRINT separator ~~
								OUTER_SET reduced = 1
							END
						END
					END
				END

			END
			
			ACTION_IF ~%res%~ STR_EQ ~~ AND ~%property%~ STR_EQ ~~ THEN BEGIN
				LAM trim_json
				OUTER_TEXT_SPRINT res ~%json%~
			END
			
		END ELSE ACTION_IF ~%property%~ STR_EQ ~~ THEN BEGIN		
			LAM trim_json
			OUTER_TEXT_SPRINT res ~%json%~
		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%\[~ THEN BEGIN //json array
			OUTER_PATCH ~%property%~ BEGIN
				REPLACE_EVALUATE CASE_SENSITIVE ~^\[\([0-9]+\)\]\(.*\)$~ BEGIN
					SET idx = ~%MATCH1%~
					
					LPF json_array_element
						INT_VAR idx = idx 
						STR_VAR json = EVAL ~%json%~ 
						RET elem = res END
					PATCH_IF NOT ~%elem%~ STR_EQ ~~ THEN BEGIN
						LPF get_json 
							STR_VAR json = EVAL ~%elem%~ property = EVAL ~%MATCH2%~	
							RET res END	
					END				
				END ~~
			END
		END  
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json	
	STR_VAR 
		json = ~~
		property = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END

	
	
DEFINE_ACTION_FUNCTION has_property
	STR_VAR
		json = ~~
		property = ~~
	RET exists
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res END
		OUTER_SET exists = NOT ~%res%~ STR_EQ ~~
	END
	
	
	
DEFINE_PATCH_FUNCTION has_property				
	STR_VAR
		json = ~~
		property = ~~
	RET exists
	BEGIN
		INNER_ACTION BEGIN
			LAF has_property 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET exists END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION get_json_value 
	STR_VAR
		json = ~~
		property = ~~
	RET	
		res
		exists
	BEGIN
		LAF get_json
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			OUTER_SET exists = 0
		END ELSE BEGIN
			OUTER_SET exists = 1
			LAF json_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
		
		
		
DEFINE_PATCH_FUNCTION get_json_value 	
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
		exists
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_value 
				STR_VAR 
					json = EVAL ~%json%~ 
					property = EVAL ~%property%~
				RET res exists END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_boolean
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No boolean property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_boolean_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_boolean
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_boolean
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_int
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res exists END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No number property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_int_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_int
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_int 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_string
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No string property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_string_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_string
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN	
			LAF get_json_string 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END









/*************************************************************************************
 ********************        Json modification functions          ********************
 *************************************************************************************/ 



DEFINE_ACTION_FUNCTION set_json
	STR_VAR
		json = ~~
		property = ~~
		value = ~~
	RET
		res
	BEGIN		
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%{~ THEN BEGIN //json object			
			LAF json_object_fields 
				STR_VAR json = EVAL ~%json%~ 
				RET size 
				RET_ARRAY fields = res END		
			
			OUTER_TEXT_SPRINT res ~~ 
			
			ACTION_IF size THEN BEGIN
				OUTER_TEXT_SPRINT prefix ~%property%~
				OUTER_TEXT_SPRINT suffix ~~
				OUTER_TEXT_SPRINT separator ~~
				OUTER_SET reduced = 1
				//iterate over property prefixes of %property% in decreasing length in search for a matching property
				OUTER_WHILE reduced BEGIN 
					OUTER_TEXT_SPRINT child ~~
					//we search in a loop instead of using VARIABLE_IS_SET because it doesn't work
					//with dots and other special characters in key names.
					ACTION_PHP_EACH fields AS field => next BEGIN
						ACTION_IF ~%field%~ STR_EQ ~%prefix%~ THEN BEGIN
							OUTER_TEXT_SPRINT child ~%next%~
						END
					END
					ACTION_IF NOT ~%child%~ STR_EQ ~~ THEN BEGIN
						LAF set_json //continue recursion with the suffix as the property
							STR_VAR json = EVAL ~%child%~ property = EVAL ~%suffix%~ value = EVAL ~%value%~
							RET res END
						OUTER_TEXT_SPRINT $fields(~%prefix%~) ~%res%~
						LAF json_object STR_VAR fields = ~fields~ RET res END
						OUTER_SET reduced = 0 //terminate the loop
					
					END ELSE BEGIN //check the next prefix property
						OUTER_SET reduced = 0
						//if %prefix% ends with ~[<idx>]~ move the indexing to the front of %suffix% 
						OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
							REPLACE_EVALUATE CASE_SENSITIVE ~\[\([0-9]+\)\]$~ BEGIN
								TEXT_SPRINT suffix ~[%MATCH1%]%separator%%suffix%~
								SET reduced = 1
								TEXT_SPRINT separator ~~									
							END ~~
						END
						//if %prefix% ends with ~.<property>~ move that simple property to the front of %suffix%
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE 
									~\%JSON_PROPERTY_SEPARATOR%\([^%JSON_PROPERTY_SEPARATOR%]*\)$~ 
								BEGIN
									TEXT_SPRINT suffix ~%MATCH1%%separator%%suffix%~
									SET reduced = 1
									TEXT_SPRINT separator ~%JSON_PROPERTY_SEPARATOR%~
								END ~~
							END
						END	
						ACTION_IF NOT reduced THEN BEGIN
							//if %prefix% is non-empty, check for a ~~ property next, moving %prefix% to %suffix%
							ACTION_IF NOT ~%prefix%~ STR_EQ ~~ THEN BEGIN //%property% is a simple property
								OUTER_TEXT_SPRINT suffix ~%prefix%%separator%%suffix%~
								OUTER_TEXT_SPRINT prefix ~~						
								OUTER_SET reduced = 1
								OUTER_TEXT_SPRINT separator ~~
							//If %property% starts with '.' check for property without that leading dot	
							END ELSE ACTION_IF ~%separator%~ STR_EQ ~%JSON_PROPERTY_SEPARATOR%~ THEN BEGIN							
								OUTER_TEXT_SPRINT prefix ~%suffix%~
								OUTER_TEXT_SPRINT suffix ~~
								OUTER_TEXT_SPRINT separator ~~
								OUTER_SET reduced = 1
							END
						END
					END
				END

				ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
					LAF validate_json STR_VAR json = EVAL ~%value%~ logprefix = ~set_json: ~ END
					//use %suffix% instead of %property% to trim a leading dot
					OUTER_TEXT_SPRINT $fields(~%suffix%~) ~%value%~ 
					LAF json_object STR_VAR fields = ~fields~ RET res END
				END				
				
			END ELSE BEGIN //size = 0
				LAF validate_json STR_VAR json = EVAL ~%value%~ logprefix = ~set_json: ~ END
				LAF json_string STR_VAR string = EVAL ~%property%~ RET field = res END
				OUTER_TEXT_SPRINT res ~{%field%: %value%}~
			END
			
		END ELSE ACTION_IF ~%property%~ STR_EQ ~~ THEN BEGIN
			//adding new field
			LAF validate_json STR_VAR json = EVAL ~%value%~ logprefix = ~set_json: ~ END
			OUTER_TEXT_SPRINT res ~%value%~

		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%\[~ THEN BEGIN 
			//json array
			OUTER_PATCH_SAVE property ~%property%~ BEGIN
				REPLACE_EVALUATE CASE_SENSITIVE ~^\[\([0-9]+\)\]\(.*\)$~ BEGIN
					SET idx = ~%MATCH1%~
					LPF json_to_raw_array STR_VAR json = EVAL ~%json%~ RET size RET_ARRAY elements = res END
					
					PATCH_IF idx < 0 OR idx > size THEN BEGIN
						PATCH_FAIL ~set_json: index %idx% out of range <0..%size%> - can't set %property%=%value% on <<%json%>>.~
					END
					
					PATCH_IF idx = size THEN BEGIN
						PATCH_IF ~%property%~ STRING_CONTAINS_REGEXP ~^\[%idx%\]$~ THEN BEGIN
							PATCH_FAIL ~set_json: empty array - can't set %property%=%value% on <<%json%>>~
						END
						LPF validate_json STR_VAR json = EVAL ~%value%~ logprefix = ~set_json: ~ END
						
						PATCH_IF size THEN BEGIN
							TEXT_SPRINT $elements(~%idx%~) ~%value%~ 
							LPF concat 
								STR_VAR array = ~elements~ prefix = ~[~ separator = ~, ~ suffix = ~]~
								RET res END
						END ELSE BEGIN
							TEXT_SPRINT res ~[%value%]~
						END
					
					END ELSE BEGIN
						INNER_PATCH_SAVE property ~%property%~ BEGIN
							REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^\[%idx%\]~ ~~
						END
						TEXT_SPRINT child $elements(~%idx%~)
						
						LPF set_json 
							STR_VAR 
								json = EVAL ~%child%~ 
								property = EVAL ~%property%~
								value = EVAL ~%value%~
							RET new = res END
						
						TEXT_SPRINT $elements(~%idx%~) ~%new%~
						LPF concat 
							STR_VAR array = ~elements~ prefix = ~[~ separator = ~, ~ suffix = ~]~
							RET res END							
					END
				END ~~
			END
		END ELSE BEGIN //not an object, not an array and %property% is not empty
			FAIL ~set_json: can't set %property%=%value% on atomic value %json%~
		END		
	END
	
	
	
DEFINE_PATCH_FUNCTION set_json	
	STR_VAR 
		json = ~~
		property = ~~
		value = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF set_json 
				STR_VAR 
					json = EVAL ~%json%~ 
					property = EVAL ~%property%~
					value = EVAL ~%value%~
				RET res END
		END
	END
	
	
	


	
/** Modifies the content of a json array given as a string around a given index. 
  * Separate arguments result in different type of modifications; providing multiple is possible.
  * Leaving the default value (~~) means that type of modification is not performed.
  * Allowed operations, and the order in which they are performed are as follows:
  *  - delete = <number>:  delete that many elements from the array, starting with index %at%;
  *  - set = <json>:       update the %at%-th element of the array to the given value
  *  - insert = <json>:    insert the new element at index %at%, pushing all items from that index 
  *                        further back (so the index of current item at %at% will be %at%+1 and so on).
  *  - insertall=<jarray>: insert all elements of the given array into the given array, pushing all
  *                        items currently at index %at% and above n slots further, where n is the number
  *                        of elements in the array.
  */
DEFINE_ACTION_FUNCTION update_json_array
	INT_VAR 
		/** Index in the modified array at which the change is made. Must be `0 <= at < size`
		  * (where size is the size of the array) for set and delete operations, 
		  * can be equal to size for insert/insertall. */
		at = 0
		/** Number of elements to delete from the array starting with index %at%. */
		delete = 0
	STR_VAR 
		/** The modified array in the Json format. */
		json = ~~
		/** Exchange the element at the given index for this one - must be valid json. */
		set = ~~
		/** Insert a new element to the array at the given index. Current element and all following are
		  * pushed up by 1. Must be valid json. */
		insert = ~~
		/** List of elements to insert at the given index in the json array format. All elements in
		  * the modified array from index %at% are pushed up to make space. */
		insertall = ~~
	RET 
		/** The array after the modification(s) in the json format. */
		res
	BEGIN		
		LAF json_to_raw_array
			STR_VAR json = EVAL ~%json%~ 
			RET size 
			RET_ARRAY array = res END
		
		ACTION_IF at < 0 OR at > size THEN BEGIN
			FAIL ~update_json_array: index %at% out of range <0..%size%>~
		END
		
		ACTION_IF delete > 0 OR NOT ~%insert%~ STR_EQ ~~ OR NOT ~%insertall%~ STR_EQ ~~ THEN BEGIN
			OUTER_FOR (i=0; i < at; ++i) BEGIN
				OUTER_TEXT_SPRINT $result(~%i%~) $array(~%i%~)
			END
			
			OUTER_SET i = at
			OUTER_SET j = at
			ACTION_IF delete > 0 THEN BEGIN
				OUTER_SET j += delete
			END	
			
			ACTION_IF NOT ~%insert%~ STR_EQ ~~ THEN BEGIN
				LAF validate_json STR_VAR
					logprefix = ~update_json_array insert: ~
					json = EVAL ~%insert%~
				END				
				OUTER_TEXT_SPRINT $result(~%i%~) ~%insert%~
				OUTER_SET i += 1
			END
			
			ACTION_IF NOT ~%insertall%~ STR_EQ ~~ THEN BEGIN
				LAF json_to_raw_array
					STR_VAR json = EVAL ~%insertall%~ 
					RET count = size RET_ARRAY elems = res END
				OUTER_FOR (k=0; k<count; ++k) BEGIN
					OUTER_TEXT_SPRINT $result(~%i%~) $elems(~%k%~)
					OUTER_SET i += 1
				END
			END
			
			ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				ACTION_IF j >= size THEN BEGIN
					FAIL ~update_json_array: set index %at% out of range.~
				END
				LAF validate_json STR_VAR
					logprefix = ~update_json_array set: ~
					json = EVAL ~%set%~
				END
				
				OUTER_TEXT_SPRINT $result(~%i%~) ~%set%~
				OUTER_SET j += 1
				OUTER_SET i += 1
			END

			OUTER_WHILE j < size BEGIN
				OUTER_TEXT_SPRINT $result(~%i%~) $array(~%j%~)
				OUTER_SET j += 1
				OUTER_SET i += 1
			END
			
			LAF concat 
				INT_VAR size = i
				STR_VAR array = ~result~ prefix = ~[~ separator = ~, ~ suffix = ~]~
				RET res END
			
		END ELSE ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
			ACTION_IF at < 0 OR at >= size THEN BEGIN
				FAIL ~update_json_array: index %at% out of range <0..%size%)~
			END
			LAF validate_json STR_VAR
				logprefix = ~update_json_array set: ~
				json = EVAL ~%set%~
			END
			
			OUTER_TEXT_SPRINT $array(~%at%~) ~%set%~
			
			LAF concat
				STR_VAR array = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
				RET res END
		
		END	ELSE BEGIN
			FAIL ~update_json_array: delete, set, insert or insertall argument required~
		END
	END
	
	
	
/** Modifies the content of a json array given as a string around a given index. 
  * Separate arguments result in different type of modifications; providing multiple is possible.
  * Leaving the default value (~~) means that type of modification is not performed.
  * Allowed operations, and the order in which they are performed are as follows:
  *  - delete = <number>:  delete that many elements from the array, starting with index %at%;
  *  - set = <json>:       update the %at%-th element of the array to the given value
  *  - insert = <json>:    insert the new element at index %at%, pushing all items from that index 
  *                        further back (so the index of current item at %at% will be %at%+1 and so on).
  *  - insertall=<jarray>: insert all elements of the given array into the given array, pushing all
  *                        items currently at index %at% and above n slots further, where n is the number
  *                        of elements in the array.
  */
DEFINE_PATCH_FUNCTION update_json_array
	INT_VAR 
		/** Index in the modified array at which the change is made. Must be `0 <= at < size`
		  * (where size is the size of the array) for set and delete operations, 
		  * can be equal to size for insert/insertall. */
		at = 0
		/** Number of elements to delete from the array starting with index %at%. */
		delete = 0
	STR_VAR 
		/** The modified array in the Json format. */
		json = ~~
		/** Exchange the element at the given index for this one - must be valid json. */
		set = ~~
		/** Insert a new element to the array at the given index. Current element and all following are
		  * pushed up by 1. Must be valid json. */
		insert = ~~
		/** List of elements to insert at the given index in the json array format. All elements in
		  * the modified array from index %at% are pushed up to make space. */
		insertall = ~~
	RET 
		/** The array after the modification(s) in the json format. */
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF update_json_array 
				INT_VAR at = at delete = delete
				STR_VAR 
					json = EVAL ~%json%~ 
					set = EVAL ~%set%~
					insert = EVAL ~%insert%~
					insertall = EVAL ~%insertall%~
				RET res END
		END
	END
		


/** Updates a json object given as a string. The update may consist of any of the following operations:
  *  - adding all fields from another object, overwriting previous values;
  *  - deleting a single field;
  *  - setting the value of a single field, adding that field if not previously present.
  * If more than one operation is requested, they are executed in that order; only one of each is possible
  * however. At least one of %merge%, %delete%, %set% input variables should be specified; ommiting any
  * means the corresponding operation will not be performed.
  */
DEFINE_ACTION_FUNCTION update_json_object
	STR_VAR
		/** Updated object given as a valid json string. */
		json = ~~
		/** Another valid json object given as a string. */
		merge = ~~
		/** Name of the field (without surrounding '"') to delete. */
		delete = ~~
		/** Name of the field (without surrounding '"') to update. */
		set = ~~
		/** New value for the updated field specified by %set%. Must be valid json if %set% is provided. */
		value = ~~
	RET 
		/** The object with the changes applied as a json string. */
		res
	BEGIN		
		LAF raw_json_object_fields
			STR_VAR json = EVAL ~%json%~
			RET size
			RET_ARRAY array = res END
		ACTION_IF NOT size THEN BEGIN		
			ACTION_IF NOT ~%merge%~ STR_EQ ~~ THEN BEGIN
				LAF update_json_object 
					STR_VAR
						json = EVAL ~%merge%~
						delete = EVAL ~%delete%~
						set = EVAL ~%set%~
						value = EVAL ~%value%~
					RET res END
					
			END ELSE ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				LAF json_string STR_VAR string = EVAL ~%set%~ RET key = res END
				
				LAF validate_json STR_VAR 
					logprefix = ~update_json_object set "%set%" value: ~ 
					json = EVAL ~%value%~ 
				END
				OUTER_TEXT_SPRINT res ~{%key%: %value%}~
			END
		
		END ELSE BEGIN
			OUTER_SET nonempty = size
			LAF json_string STR_VAR string = EVAL ~%delete%~ RET deletekey = res END
			
			ACTION_IF NOT ~%delete%~ STR_EQ ~~ 
			      AND VARIABLE_IS_SET $array(~%deletekey%~)
				  AND NOT ~%delete%~ STR_EQ ~%set%~ THEN BEGIN
						
				ACTION_PHP_EACH array AS key => value BEGIN
					ACTION_IF NOT ~%deletekey%~ STR_EQ ~%key%~ THEN BEGIN
						OUTER_TEXT_SPRINT $newarray(~%key%~) ~%value%~
					END
				END
				OUTER_SET nonempty -= 1
				OUTER_TEXT_SPRINT fields ~newarray~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT deletekey ~"~ //invalid json, ergo will never equal
				OUTER_TEXT_SPRINT fields ~array~
			END
			
			ACTION_IF NOT ~%merge%~ STR_EQ ~~ THEN BEGIN
				LAF raw_json_object_fields 
					STR_VAR json = EVAL ~%merge%~ 
					RET count = size 
					RET_ARRAY merged = res END

				ACTION_IF count THEN BEGIN					
					ACTION_PHP_EACH merged AS key => value BEGIN
						ACTION_IF NOT ~%deletekey%~ STR_EQ ~%key%~ THEN BEGIN
							OUTER_TEXT_SPRINT $~%fields%~(~%key%~) ~%value%~
							OUTER_SET nonempty = 1
						END
					END
				END
			END
			
			ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				LAF validate_json STR_VAR 
					logprefix = ~update_json_object set='%set%' value: ~
					json = EVAL ~%json%~ 
				END
				
				LAF json_string STR_VAR string = EVAL ~%set%~ RET setkey = res END
				
				OUTER_TEXT_SPRINT $~%fields%~(~%setkey%~) ~%value%~
				OUTER_SET nonempty = 1
			END
			
			ACTION_IF nonempty THEN BEGIN
				LAF json_object STR_VAR rawfields = EVAL ~%fields%~ RET res END
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~{}~
			END
			
		END
	END
	


/** Updates a json object given as a string. The update may consist of any of the following operations:
  *  - adding all fields from another object, overwriting previous values;
  *  - deleting a single field;
  *  - setting the value of a single field, adding that field if not previously present.
  * If more than one operation is requested, they are executed in that order; only one of each is possible
  * however. At least one of %merge%, %delete%, %set% input variables should be specified; ommiting any
  * means the corresponding operation will not be performed.
  */
DEFINE_PATCH_FUNCTION update_json_object
	STR_VAR
		/** Updated object given as a valid json string. */
		json = ~~
		/** Another valid json object given as a string. */
		merge = ~~
		/** Name of the field (without surrounding '"') to delete. */
		delete = ~~
		/** Name of the field (without surrounding '"') to update. */
		set = ~~
		/** New value for the updated field specified by %set%. Must be valid json if %set% is provided. */
		value = ~~
	RET 
		/** The object with the changes applied as a json string. */
		res
	BEGIN		
		INNER_ACTION BEGIN
			LAF update_json_object 
				STR_VAR 
					json = EVAL ~%json%~ 
					merge = EVAL ~%merge%~
					delete = EVAL ~%delete%~
					set = EVAL ~%set%~
					value = EVAL ~%value%~
				RET res END
		END
	END






DEFINE_ACTION_FUNCTION json_array_stack
	INT_VAR
		pop = 0
	STR_VAR
		json = ~[]~
		push = ~~
		pushall = ~~
	RET
		res
		top
	BEGIN
		OUTER_PATCH_SAVE res ~%json%~ BEGIN
			SET offset = 0
			LPM skip_whitespace_before_json

			PATCH_IF NOT ~%peek%~ STR_EQ ~[~ THEN BEGIN
				PATCH_FAIL ~json_array_stack: invalid json array <<%json%>>.~

			END ELSE BEGIN
				SET i = 0
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset srclength peek END
				
				WHILE i < pop AND offset < srclength AND NOT ~%peek%~ STR_EQ ~]~ BEGIN
					PATCH_IF i THEN BEGIN
						PATCH_IF NOT ~%peek%~ STR_EQ ~,~ THEN BEGIN
							LPF report_invalid_json 
								STR_VAR msg = ~json_array_stack: missing ',' in the json array~ 
							END
						END
						LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET offset END
					END
					
					LPF skip_json INT_VAR offset = offset RET offset skipped END					
					PATCH_IF NOT skipped THEN BEGIN
						LPF report_invalid_json 
							STR_VAR msg = ~json_array_stack: invalid json element %i%~ 
						END
					END
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
					
					SET i += 1			
				END				

				SET write_offset = start + 1

				SET pushall_len = 0
				PATCH_IF NOT ~%pushall%~ STR_EQ ~~ THEN BEGIN
					LPF is_json_array STR_VAR json = EVAL ~%pushall%~ RET is_array END
					PATCH_IF NOT is_array THEN BEGIN
						PATCH_FAIL ~json_array_stack: invalid json array given to push on the stack: <<%pushall%>>.~
					END
					
					INNER_PATCH_SAVE contents ~%pushall%~ BEGIN
						REPLACE_TEXTUALLY EVALUATE_REGEXP 
							~^[%WHITESPACE_CHARS%]*\[\([%WHITESPACE_CHARS]*\)\(.*\)%WHITESPACE_RX%\]%WHITESPACE_RX%$~
							~\2~
					END
					SET pushall_len = STRING_LENGTH ~%contents%~
				END

				SET push_len = STRING_LENGTH ~%push%~
				SET len = push_len + pushall_len
				PATCH_IF len > 0 THEN BEGIN
					SET comma = 0 //if we are pushing to a single-element stack we need to add ','
					PATCH_IF NOT ~%peek%~ STR_EQ ~,~ AND NOT ~%peek%~ STR_EQ ~]~ THEN BEGIN
						SET comma = 2
					END
					PATCH_IF push_len > 0 AND pushall_len > 0 THEN BEGIN
						SET len += 2 //for a comma between push and pushall
					END
					SET end = write_offset + len + comma
					PATCH_IF end > offset THEN BEGIN
						INSERT_BYTES write_offset (end - offset)
						SET offset = end
					END
					
					PATCH_IF push_len THEN BEGIN
						LPF validate_json STR_VAR json = EVAL ~%push%~ END
						
						WRITE_ASCIIE write_offset ~%push%~
						SET write_offset += push_len
						PATCH_IF pushall_len THEN BEGIN
							WRITE_ASCII write_offset ~, ~
							SET write_offset += 2
						END
					END
					
					PATCH_IF pushall_len THEN BEGIN
						WRITE_ASCIIE write_offset ~%contents%~
						SET write_offset += pushall_len
					END
					
					PATCH_IF comma THEN BEGIN
						WRITE_ASCII (write_offset) ~, ~
					END
					SET write_offset += comma

				END
				
				PATCH_IF write_offset = start + 1 AND ~%peek%~ STR_EQ ~,~ THEN BEGIN
					SET offset += 1
				END
				DELETE_BYTES write_offset (offset - write_offset)
				
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset END
				LPF skip_json INT_VAR offset = offset RET skipped END
				READ_ASCII offset top (skipped)
			END				
		END
	END



DEFINE_PATCH_FUNCTION json_array_stack
	INT_VAR
		pop = 0
	STR_VAR
		json = ~~
		push = ~~
		pushall = ~~
	RET
		res
		top
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_stack 
				INT_VAR pop = pop
				STR_VAR json = EVAL ~%json%~ push = EVAL ~%push%~ pushall = EVAL ~%pushall%~
				RET res top END
		END
	END








/*************************************************************************************
 ********************       Json transformation functions         ********************
 *************************************************************************************/ 



/** Applies custom patching to the json element at the given offset in the patch buffer.
  * Recursively traverses the json structure and applies the specified patch operation to
  * elements which path match the given selector %select%. The patch consists of four optional 
  * steps:
  *  - matching the found element with the given regular expression %match% - if the match
  *    fails, all other steps are skipped and the element is treated as if it did not match
  *    the %path% selector.
  *  - replacing the matched element with the given %patch%, which can contain regular expression
  *    group references ~\0~, ~\1~ and so on, as if the element was the subject of
  *    REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~%match%~ ~%patch%~
  *  - calling the given action function %map% with arguments %json% - the result of previous steps
  *    and %property% - the property path leading to the patched element.
  *  - calling an action macro %macro% with variables %json% and %property% set to the matched 
  *  element and its fully resolved property path.
  *  The final result can be one of the following, depending on the value of argument %as%:
  *  - if %as% is not specified or empty, the patching happens 'in place' with the result of the patch
  *    replacing the matched element in the bufer.
  *  - if %as% equals ~[]~, the root element (as seen from offset %offset%) is replaced with a json array
  *    containing all patched elements; all not matched and surrounding elements are discarded.
  *  - if %as% equals ~{}~, the root element (as seen from offset %offset%) is replaced with a json object
  *    with matched elements as fields. The names of the fields are the paths to the matched elements
  *    and the values are the results of applying the patch. As with the previous case, any not matched
  *    elements are not included in the result.
  * The patching is limited to the first json element in the buffer following the offset %offset%;
  * any following data is ignored.
  */
DEFINE_PATCH_FUNCTION patch_json
	INT_VAR 
		/** The offset in the current patch buffer from which the patching starts. Must be either exactly
		  * at the start of a json element, or with only whitespace characters before a valid json element.
		  * Defaults to the beginning of the buffer. */
		offset = 0
	STR_VAR
		/** Path selector pointing at elements which should be patched. 
		  * It can consist of any sequence of:
		  *  - a json string (in double quotes) matches an object field of the same name;
		  *  - a '*' character matches all fields of an object;
		  *  - ~[%n%]~ matches the n-th element of an array;
		  *  - ~[%n%-%m%]~ matches the elements of an array with indices between %n% (inclusive) 
		  *    and %m% (exclusive). Any of the two values can be missing, denoting the start 
		  *    and the end of the array, respectively.
		  * All whitespace surrounding the individual path elements is ignored.
		  * An empty selector points directly to the root element; this is the default value.
		  * As follows, the selector ~[-] "abilities" *~ would match all field values of any object
		  * under the "abilities" field of any object in the root array. */
		select = ~~
		/** A regular expression which found elements must match in order to be patched/included. 
		 *  If not present, it will match any element under the specified path. */
		match = ~.*~
		/** The replacement value for the matched elements. Defaults to ~\0~, meaning the matched
		  * element is used without changes. */
		patch = ~\0~
		/** If not empty, it is treated as the name of an action function to invoke for everything
		  * matched element. It should accept arguments %json% for the matched value and %property%
		  * for the property path leading to it. */
		map = ~~
		/** If not empty, it is treated as a name of an action macro to execute for each matched element.
		  * Before each call, the %json% variable is set to the matched element, while %property% to its property path. */
		macro = ~~
		/** Specifies the manner in which the patched elements are returned. If omitted, the patched
		  * simply values replace the originals in the buffer. If equal to ~[]~, the root json
		  * element is completely replaced with an array containing directly all patched elements.
		  * If equal to ~{}~, the root json element is replaced with a json object with fields named
		  * after concrete paths to found elements (i.e., without any wildcards) and their values
		  * are the results of applying the patch. */		  
		as = ~~
	RET 
		/** Offset in the buffer immediately following the written result. */
		offset
	BEGIN
		SET extract = 0
		PATCH_IF ~%as%~ STR_EQ ~[]~ OR ~%as%~ STR_EQ ~array~ THEN BEGIN
			SET extract = 1
			TEXT_SPRINT close ~]~
			TEXT_SPRINT empty ~[]~
		END ELSE PATCH_IF ~%as%~ STR_EQ ~{}~ OR ~%as%~ STR_EQ ~object~ OR ~%as%~ STR_EQ ~dict~ BEGIN
			SET extract = 2
			TEXT_SPRINT close ~}~
			TEXT_SPRINT empty ~{}~
		END
		INNER_PATCH_SAVE select ~%select%~ BEGIN //remove any trailing whitespace so we don't need to check for it later
			REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~%WHITESPACE_RX%$~ ~~
		END
		
		LPF patch_json_recursion
			INT_VAR 
				offset = offset
				extract = extract
				write_offset = offset
			STR_VAR
				property = ~~
				select = EVAL ~%select%~
				match = EVAL ~%match%~
				patch = EVAL ~%patch%~
				map = EVAL ~%map%~ 
				macro = EVAL ~%macro%~
			RET offset write_offset count
		END
		PATCH_IF extract THEN BEGIN
			SET extra_chars = 1
			PATCH_IF count = 0 THEN BEGIN
				SET extra_chars = 2
				TEXT_SPRINT close ~%empty%~
			END	
				
			PATCH_IF write_offset + extra_chars <= offset THEN BEGIN
				WRITE_ASCIIE write_offset ~%close%~
				DELETE_BYTES (write_offset + extra_chars) (offset - write_offset - extra_chars)
			END ELSE BEGIN
				INSERT_BYTES write_offset extra_chars
				WRITE_ASCIIE write_offset ~%close%~
			END
			SET offset = write_offset + extra_chars
		END 
	END
	
	

DEFINE_PATCH_FUNCTION patch_json_recursion
	INT_VAR 
		offset = 0
		extract = 0
		write_offset = 0
		count = 0
	STR_VAR
		property = ~~
		select = ~~
		match = ~.*~
		patch = ~\0~
		map = ~~
		macro = ~~
	RET
		offset write_offset count
	BEGIN		
		PATCH_IF ~%select%~ STR_EQ ~~ THEN BEGIN
			LPF patch_json_property
				INT_VAR 
					offset = offset 
					extract = extract
					write_offset = write_offset
					count = count
				STR_VAR 
					property = EVAL ~%property%~
					match = EVAL ~%match%~
					patch = EVAL ~%patch%~
					map = EVAL ~%map%~
					macro = EVAL ~%macro%~
				RET offset write_offset count
			END	
			
		END ELSE BEGIN //%select% is not empty: recurse down the json tree
			LPM skip_whitespace_before_json

			PATCH_IF ~%peek%~ STR_EQ ~{~ THEN BEGIN //json object			
				LPF patch_json_object_internals 
					INT_VAR 
						offset = start 
						write_offset = write_offset
						extract = extract
						count = count
					STR_VAR 
						property = EVAL ~%property%%JSON_PROPERTY_SEPARATOR%~
						select = EVAL ~%select%~
						match = EVAL ~%match%~ 
						patch = EVAL ~%patch%~
						map = EVAL ~%map%~
						macro = EVAL ~%macro%~
					RET offset write_offset count
				END

			END ELSE PATCH_IF ~%peek%~ STR_EQ ~[~ THEN BEGIN //json array
				LPF patch_json_array_internals
					INT_VAR 
						offset = start
						write_offset = offset
						extract = extract
						count = count
					STR_VAR 
						property = EVAL ~%property%~
						select = EVAL ~%select%~
						match = EVAL ~%match%~
						patch = EVAL ~%patch%~
						map = EVAL ~%map%~
						macro = EVAL ~%macro%~
					RET offset write_offset count
				END
			
			END ELSE BEGIN //an atomic json value
				LPF read_json INT_VAR offset = offset RET json END
				LPF skip_json INT_VAR offset = offset RET offset END
			END
		END  
	END



DEFINE_PATCH_FUNCTION map_patched_json
	INT_VAR 
		offset = 0
	STR_VAR
		property = ~~
		match = ~~
		patch = ~~
		map = ~~
		macro = ~~
	RET 
		offset res nochange
	BEGIN
		PATCH_IF ~%patch%~ STR_EQ ~~ THEN BEGIN					
			PATCH_IF ~%macro%~ STR_EQ ~~ THEN BEGIN
				LPF skip_json INT_VAR offset = offset RET offset skipped END
				
				PATCH_IF NOT skipped THEN BEGIN
					LPF report_invalid_json
						STR_VAR msg = EVAL ~map_patched_json: malformed json~
					END
				END
			END ELSE BEGIN
				LPF read_json INT_VAR offset = offset RET offset json = res END
				INNER_ACTION BEGIN
					LAM ~%macro%~ 
				END
			END
			TEXT_SPRINT res ~~
			SET nochange = 0						
		
		END ELSE BEGIN		
			LPF read_json INT_VAR offset = offset RET offset res = json END
			
			SET nochange = 1
			PATCH_IF ~%match%~ STR_EQ ~.*~ 
				  OR NOT ~%res%~ STRING_MATCHES_REGEXP ~^%match%$~ THEN BEGIN
				
				PATCH_IF NOT ~%macro%~ STR_EQ ~~ THEN BEGIN
					TEXT_SPRINT json ~%res%~
				END
				PATCH_IF NOT ~%patch%~ STR_EQ ~\0~ THEN BEGIN
					INNER_PATCH_SAVE res ~%res%~ BEGIN
						SET nochange = 0
						REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^%match%$~ ~%patch%~
					END
				END

				INNER_ACTION BEGIN
					ACTION_IF NOT ~%map%~ STR_EQ ~~ AND NOT ~%res%~ STR_EQ ~~ THEN BEGIN
						OUTER_SET nochange = 0
						LAF ~%map%~ STR_VAR json = EVAL ~%res%~ property = EVAL ~%property%~ RET res END
					END
					ACTION_IF NOT ~%macro%~ STR_EQ ~~ THEN BEGIN
						OUTER_TEXT_SPRINT patch ~%res%~ 
						LAM ~%macro%~
					END
				END
			END
		END	
	END
	
	

/** Internal function called from patch_json. End of patch recursion reached with the end of json path.
  * matches and maps json at the given %offset% and writes the replacement to %write_offset%,
  * shifting data if needed.
  */
DEFINE_PATCH_FUNCTION patch_json_property
	INT_VAR 
		offset = 0
		extract = 0
		write_offset = 0
		write_limit = 0 - 1
		count = 0
		first = 0
	STR_VAR
		property = ~~
		match = ~.*~
		patch = ~\0~
		map = ~~
		macro = ~~
	RET
		offset write_offset write_limit count
	BEGIN
		LPM skip_whitespace_before_json
		LPF map_patched_json
			INT_VAR offset = start
			STR_VAR 
				property = EVAL ~%property%~ 
				match = EVAL ~%match%~ patch = EVAL ~%patch%~ 
				map = EVAL ~%map%~ macro = EVAL ~%macro%~
			RET end = offset nochange res 
		END
		LPF read_json INT_VAR offset = offset RET input = json END
		PATCH_IF write_limit < 0 THEN BEGIN
			SET write_limit = end
		END
		PATCH_IF extract THEN BEGIN //replace everything between write_offset and offset with %prefix%				
			PATCH_IF extract = 2 THEN BEGIN //extract as a dict with paths as keys
				LPF json_string STR_VAR string = EVAL ~%property%~ RET field = res END
				PATCH_IF count = 0 THEN BEGIN
					TEXT_SPRINT prefix ~{%field%: ~
				END ELSE BEGIN
					TEXT_SPRINT prefix ~, %field%: ~
				END
			END ELSE BEGIN //extract as an array
				PATCH_IF count = 0 THEN BEGIN
					TEXT_SPRINT prefix ~[~
				END ELSE BEGIN
					TEXT_SPRINT prefix ~, ~
				END
			END
			SET extra = STRING_LENGTH ~%prefix%~
			SET length = STRING_LENGTH ~%res%~
			SET newend = write_offset + extra + length
			
			PATCH_IF nochange THEN BEGIN	
				SET shift = start - write_offset  - extra				

				PATCH_IF shift > 0 THEN BEGIN //shift back %res% to write_offset + prefix
					WRITE_ASCIIE write_offset ~%prefix%~
					WRITE_ASCIIE (write_offset + extra) ~%res%~
					SET offset = end
					SET write_offset += extra + STRING_LENGTH ~%res%~
				END ELSE BEGIN //not enough or exactly the right space before offset
					INSERT_BYTES write_offset (0 - shift)
					WRITE_ASCIIE write_offset ~%prefix%~
					SET offset = end - shift
					SET write_offset = end - shift
				END
				SET count += 1
				
			END ELSE BEGIN
				SET offset = end
				PATCH_IF length THEN BEGIN //if %res% is empty we must not write %prefix%
					PATCH_IF newend <= write_limit THEN BEGIN //simply write %res% at %write_offset%
						WRITE_ASCIIE write_offset ~%prefix%~
						WRITE_ASCIIE (write_offset + extra) ~%res%~
					END ELSE BEGIN //need to make space so we don't overwrite non-read portion of the buffer
						INSERT_BYTES write_offset (newend - write_limit)
						WRITE_ASCIIE write_offset ~%prefix%~
						WRITE_ASCIIE (write_offset + extra) ~%res%~
						SET write_limit = newend
						SET offset = newend
					END
					SET write_offset = newend
					SET count += 1
				END
			END
			
		END ELSE BEGIN //leave the non-matched buffer before offset and replace only the mapped fragment
			SET count += 1
			PATCH_IF nochange THEN BEGIN
				SET offset = end
			END ELSE BEGIN
				SET len = STRING_LENGTH ~%res%~			
				PATCH_IF len = 0 THEN BEGIN //delete the value from the input starting from %write_offset%
					SET count -= 1
					PATCH_IF first THEN BEGIN //mapped value was the first in an object/array
						LPF skip_buffer_whitespace INT_VAR offset = end RET end = offset peek END
						PATCH_IF ~%peek%~ STR_EQ ~,~ THEN BEGIN //swallow the now leading ','
							SET end += 1
						END
					END
					DELETE_BYTES write_offset (end - write_offset)
					SET offset = write_offset
				END ELSE PATCH_IF len < end - start THEN BEGIN
					DELETE_BYTES start (end - start - len)					
				END ELSE BEGIN
					INSERT_BYTES start (start + len - end)
				END
				WRITE_ASCIIE start ~%res%~ 
				SET offset = start + len
				SET write_offset += len
			END
		END
	END



/** Internal function called from patch_json when a json_array is encountered at %offset%. */
DEFINE_PATCH_FUNCTION patch_json_array_internals
	INT_VAR
		offset = 0
		extract = 0
		write_offset = 0
		count = 0
	STR_VAR
		property = ~~
		select = ~~
		match = ~.*~
		patch = ~\0~
		map = ~~
	RET 
		offset write_offset count
	BEGIN
		TEXT_SPRINT current ~~
		INNER_PATCH_SAVE suffix ~%select%~ BEGIN //check if it starts with an indexing expression [..]
			REPLACE_EVALUATE ~^[%WHITESPACE_CHARS%]*\(\[\([0-9]*\)\(-\([0-9]*\)\)?\]\)\(.*\)$~ BEGIN
				TEXT_SPRINT current ~%MATCH1%~
				PATCH_IF ~%MATCH2%~ STR_EQ ~~ THEN BEGIN //no lower bound
					SET from = 0
					SET until = 0
				END ELSE BEGIN //%MATCH2% has the lower bound
					SET from = ~%MATCH2%~
					SET until = from + 1
				END
				PATCH_IF VARIABLE_IS_SET MATCH3 THEN BEGIN //index range 
					PATCH_IF ~%MATCH4%~ STR_EQ ~~ THEN BEGIN //no upper bound
						SET until = MAX_INT
					END ELSE BEGIN //%MATCH4% is the upper bound
						SET until = ~%MATCH4%~
					END
				END					
			END ~%MATCH5%~
		END	
		PATCH_IF ~%current%~ STR_EQ ~~ THEN BEGIN //check if %select% starts with '*' or '**'
			INNER_PATCH_SAVE suffix ~%select%~ BEGIN
				REPLACE_EVALUATE ~^[%WHITESPACE_CHARS%]*\(\*\(\*\)?\)\(.*\)$~ BEGIN
					TEXT_SPRINT current ~%MATCH1%~
					SET from = 0
					SET until = MAX_INT
				END ~%MATCH3%~
			END
		END

		PATCH_IF ~%current%~ STR_EQ ~~ THEN BEGIN //%select% does not start with an indexing property
			PATCH_LOG ~patch_json_array_internals: path <<%select%>> does not apply to json array at #%offset% under <<%property%>>.~
			
			LPF skip_json_array INT_VAR offset = offset RET offset skipped END
			PATCH_IF NOT skipped THEN BEGIN
				LPF report_invalid_json
					STR_VAR msg = EVAL ~patch_json_array_internals: malformed json array under <<%property%>>~
				END
			END
			
		END ELSE BEGIN	
			//from and until form an inclusive range of indices to patch
			LPM skip_whitespace_before_json
			PATCH_IF NOT ~%peek%~ STR_EQ ~[~ THEN BEGIN
				LPF report_invalid_json
					INT_VAR at = start
					STR_VAR msg = EVAL ~patch_json_array_internals: expected '[' but got '%peek%' under <<%property%>>~
				END
			END
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset peek END
			
			SET index = 0
			SET first = 1
			
			WHILE NOT ~%peek%~ STR_EQ ~]~ AND NOT ~%peek%~ STR_EQ ~~ BEGIN
				SET mark = offset
				PATCH_IF NOT extract THEN BEGIN
					SET write_offset = mark //if we delete this element we swallow the preceeding comma
				END
				PATCH_IF NOT first THEN BEGIN //consume the field separator ','
					PATCH_IF ~%peek%~ STR_EQ ~,~ THEN BEGIN
						SET offset += 1
					END ELSE BEGIN
						LPF report_invalid_json
							STR_VAR msg = EVAL ~patch_json_array_internals: invalid json; expected ',' but got '%peek%' under <<%property%[%index%]>>~
						END
					END
				END
				
				PATCH_IF index < from OR index >= until THEN BEGIN
					LPF skip_json INT_VAR offset = offset RET offset skipped END
					
					PATCH_IF NOT skipped THEN BEGIN
						READ_ASCII start array_prefix (offset - start)
						PATCH_FAIL ~patch_json_array_internals: invalid json element at #%offset% following <<%array_prefix%>> under <<%property%[%index%]>>.~
					END
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
					SET first = 0
					
				END ELSE BEGIN
					PATCH_IF ~%suffix%~ STR_EQ ~~ THEN BEGIN
						//substitute this element for the mapped replacement
						LPF patch_json_property
							INT_VAR
								offset = offset
								write_offset = write_offset
								extract = extract
								count = count
								first = first
							STR_VAR
								property = EVAL ~%property%[%index%]~
								match = EVAL ~%match%~ patch = EVAL ~%patch%~ 
								map = EVAL ~%map%~ macro = EVAL ~%macro%~
							RET end = offset write_offset count
						END
						PATCH_IF extract OR end > mark THEN BEGIN
							SET first = 0 //patch_json_property deleted the following ',' with the first element
						END
						SET offset = end
						
					END ELSE BEGIN //recursively patch this field
						LPF patch_json_recursion
							INT_VAR 
								offset = offset
								write_offset = write_offset
								extract = extract
								count = count
							STR_VAR 
								property = EVAL ~%property%[%index%]~ 
								select = EVAL ~%suffix%~
								match = EVAL ~%match%~
								patch = EVAL ~%patch%~
								map = EVAL ~%map%~
								macro = EVAL ~%macro%~
							RET	offset write_offset count
						END
					END
					SET first = 0					
				END
				
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				SET index += 1
			END	

			PATCH_IF NOT ~%peek%~ STR_EQ ~]~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~patch_json_array_internals: expected ',' or ']'; got '%peek%' at #%offset% following '%prefix%' under <<%property%>>.~
			END 
			SET offset += 1		
		END			
	END
	
	
	
/** Internal function called from patch_json to proceed when the value at %offset% is a json object. */	
DEFINE_PATCH_FUNCTION patch_json_object_internals
	INT_VAR 
		offset = 0
		write_offset = 0
		extract = 0
		count = 0
	STR_VAR
		property = ~~
		select = ~~
		match = ~~
		patch = ~~
		map = ~~
		macro = ~~
	RET
		offset write_offset count
	BEGIN
		TEXT_SPRINT current ~~
		TEXT_SPRINT regexp ~~
		INNER_PATCH_SAVE suffix ~%select%~ BEGIN //split %select% into current/suffix if it starts with a string
			TEXT_SPRINT MATCH3 ~~ //because non-matching group leads to retaining the value from a previous match
			REPLACE_EVALUATE ~^\([%WHITESPACE_CHARS%]*\(\([rR]?\)\(%JSON_STRING_RX%\)\|\*\(\*?\)\)\)\(.*\)$~ BEGIN
				PATCH_IF NOT ~%MATCH3%~ STR_EQ ~~ THEN BEGIN
					LPF json_string_value STR_VAR json = EVAL ~%MATCH4%~ RET regexp = res END
				END ELSE BEGIN
					TEXT_SPRINT current ~%MATCH2%~
				END
				SET prefix = STRING_LENGTH ~%MATCH1%~
				LPF SUBSTRING 
					INT_VAR start = prefix length = STRING_LENGTH ~%select%~ - prefix
					STR_VAR string = EVAL ~%select%~
					RET trimmed = substring END
			END ~%trimmed%~
		END
		PATCH_IF ~%current%~ STR_EQ ~~ AND ~%regexp%~ STR_EQ ~~ THEN BEGIN //%select% does not start with a string or regexp
			PATCH_LOG ~patch_json_object_internals: path <<%select%>> does not apply to json object at #%offset%.~
			
			LPF skip_json_object INT_VAR offset = offset RET offset skipped END
			PATCH_IF NOT skipped THEN BEGIN
				LPF report_invalid_json	
					STR_VAR msg = EVAL ~patch_json_object_internals: malformed json object under <<%property%>>~
				END
			END

		END ELSE BEGIN	
			//current has the raw field name of the next json value down the line
			LPM skip_whitespace_before_json
			PATCH_IF NOT ~%peek%~ STR_EQ ~{~ THEN BEGIN
				LPF report_invalid_json
					INT_VAR at = start
					STR_VAR msg = EVAL ~patch_json_object_internals: expected '{' but got '%peek%' under <<%property%>>~
				END
			END
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset peek END
			
			SET first = 1
			WHILE NOT ~%peek%~ STR_EQ ~}~ AND NOT ~%peek%~ STR_EQ ~~ BEGIN
				SET mark = offset
				PATCH_IF NOT extract THEN BEGIN
					SET write_offset = offset //if we delete the field we erase from this point with the key
				END
				PATCH_IF NOT first THEN BEGIN //consume the field separator ','
					PATCH_IF ~%peek%~ STR_EQ ~,~ THEN BEGIN
						SET offset += 1
					END ELSE BEGIN
						LPF report_invalid_json
							STR_VAR msg = EVAL ~patch_json_object_internals: invalid json; expected ',' but got '%peek%' inside object under <<%property%>>~
						END
					END
				END

				LPF read_raw_json_string INT_VAR offset = offset RET offset field = res END				
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
				LPF json_string_value STR_VAR json = EVAL ~%field%~ RET name = res END
				
				PATCH_IF NOT ~%peek%~ STR_EQ ~:~ THEN BEGIN
					READ_ASCII start object_prefix (mark - start)
					PATCH_FAIL ~patch_json_object_internals: missing ':' after field %field% at #%offset% following <<%object_prefix%>> under <<%property%>>.~
				END
				SET offset += 1
				
				PATCH_IF ~%current%~ STR_EQ ~*~ OR ~%current%~ STR_EQ ~%field%~ 
				      OR NOT ~%regexp%~ STR_EQ ~~ AND NOT ~%name%~ STRING_MATCHES_REGEXP ~%regexp%~ 
				THEN BEGIN
					PATCH_IF ~%suffix%~ STR_EQ ~~ THEN BEGIN
						//substitute this field's value for the mapped replacement
						LPF patch_json_property
							INT_VAR 
								offset = offset 
								write_offset = write_offset 
								extract = extract
								count = count
								first = first
							STR_VAR
								property = EVAL ~%property%%name%~
								match = EVAL ~%match%~ patch = EVAL ~%patch%~ 
								map = EVAL ~%map%~ macro = EVAL ~%macro%~
							RET end = offset write_offset count
						END
						PATCH_IF extract OR end > mark THEN BEGIN //don't expect ',' if it was deleted with the element
							SET first = 0 
						END
						SET offset = end
						
					END ELSE BEGIN //recursively patch this field
						LPF patch_json_recursion
							INT_VAR 
								offset = offset 
								extract = extract 
								write_offset = write_offset
								count = count
							STR_VAR 
								property = EVAL ~%property%%name%~ 
								select = EVAL ~%suffix%~
								match = EVAL ~%match%~
								patch = EVAL ~%patch%~
								map = EVAL ~%map%~
								macro = EVAL ~%macro%~
							RET	offset write_offset count
						END
						SET first = 0
					END
					//todo: **
				END ELSE BEGIN //leave the field as is
				
					LPF skip_json INT_VAR offset = offset RET offset skipped END
					PATCH_IF NOT skipped THEN BEGIN
						READ_ASCII start object_prefix (mark - start)
						PATCH_FAIL ~patch_json_object_internals: invalid json field '%field%' following <<%object_prefix%>>.~
					END
					SET first = 0	
				END
				
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
			END	

			PATCH_IF NOT ~%peek%~ STR_EQ ~}~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~patch_json_object_internals: expected ',' or '}'; got '%peek%' at #%offset% following '%prefix%' under <<%property%>>.~
			END 
			SET offset += 1		
		END		
	END






DEFINE_ACTION_FUNCTION map_json
	STR_VAR 
		json = ~~
		select = ~~
		match = ~.*~
		patch = ~\0~
		map = ~~
		macro = ~~
		as = ~~
	RET
		res
	BEGIN
		OUTER_PATCH_SAVE res ~%json%~ BEGIN
			LPF patch_json STR_VAR 
				select = EVAL ~%select%~ 
				match = EVAL ~%match%~ patch = EVAL ~%patch%~
				map = EVAL ~%map%~
				macro = EVAL ~%macro%~
				as = EVAL ~%as%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION map_json
	STR_VAR 
		json = ~~
		select = ~~
		match = ~.*~
		patch = ~\0~
		map = ~~
		macro = ~~
	RET
		res
	BEGIN
		INNER_PATCH_SAVE res ~%json%~ BEGIN
			LPF patch_json STR_VAR 
				select = EVAL ~%select%~ 
				match = EVAL ~%match%~ patch = EVAL ~%patch%~
				map = EVAL ~%map%~
				macro = EVAL ~%macro%~
				as = EVAL ~%as%~
			END
		END
	END
	





DEFINE_PATCH_FUNCTION group_json_array_elements
	INT_VAR offset = 0
	STR_VAR	by = ~~
	RET	size offset
	RET_ARRAY res
	BEGIN
		CLEAR_ARRAY res
		SET size = 0
		LPM skip_whitespace_before_json
		
		PATCH_IF NOT ~%peek%~ STR_EQ ~[~ THEN BEGIN
			LPF report_invalid_json
				STR_VAR msg = EVAL ~group_json_array_elements: invalid json array; expected '[' but got '%peek%'.~
			END
		END
		SET offset = start
		WHILE offset < srclength AND NOT ~%peek%~ STR_EQ ~]~ BEGIN
			PATCH_IF offset > start THEN BEGIN
				PATCH_IF NOT ~%peek%~ STR_EQ ~,~ THEN BEGIN
					LPF report_invalid_json
						STR_VAR msg = EVAL ~group_json_array_elements: invalid json array - expected ',' but got '%peek%'.~
					END
				END
			END
			SET offset += 1
			LPF skip_buffer_whitespace INT_VAR offset = offset RET offset srclength peek END

			LPF read_json INT_VAR offset = offset RET offset json END
			LPF get_json STR_VAR json = EVAL ~%json%~ property = EVAL ~%by%~ RET key = res END

			PATCH_IF NOT ~%key%~ STR_EQ ~~ THEN BEGIN
				PATCH_IF VARIABLE_IS_SET $res(~%key%~) THEN BEGIN
					TEXT_SPRINT group $res(~%key%~) 
					SET length = $group_size(~%key%~)
				END ELSE BEGIN
					TEXT_SPRINT group ~[]~
					SET length = 0
					SET size += 1
				END
				LPF update_json_array 
					INT_VAR at = length
					STR_VAR insert = EVAL ~%json%~ json = EVAL ~%group%~ 
					RET group = res END
				TEXT_SPRINT $res(~%key%~) ~%group%~
				SET $group_size(~%key%~) = length + 1
			END
			
			LPF skip_buffer_whitespace INT_VAR offset = offset RET offset peek END
		END
		
		PATCH_IF NOT ~%peek%~ STR_EQ ~]~ THEN BEGIN
			LPF report_invalid_json
				STR_VAR msg = EVAL ~group_json_array_elements: invalid json array - expected ']' but got EOF.~
			END
		END
		
		PATCH_IF NOT size THEN BEGIN
			TEXT_SPRINT $res(~~) ~<empty array; check size before accessing>~
		END
	END



DEFINE_ACTION_FUNCTION index_json	
	STR_VAR 
		json = ~~
		by = ~~
	RET	size
	RET_ARRAY res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF group_json_array_elements STR_VAR by = EVAL ~%by%~ RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION index_json
	STR_VAR
		json = ~~
		by = ~~
	RET size
	RET_ARRAY res
	BEGIN	
		INNER_PATCH ~%json%~ BEGIN
			LPF group_json_array_elements STR_VAR by = EVAL ~%by%~ RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION group_json
	INT_VAR
		literal = 0
	STR_VAR
		json = ~~
		by = ~~
	RET res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF group_json_array_elements STR_VAR by = EVAL ~%by%~ RET size RET_ARRAY index = res END
		END
		OUTER_PATCH_SAVE res ~~ BEGIN
			PATCH_IF literal THEN BEGIN
				LPF write_json_object INT_VAR size = size STR_VAR rawfields = ~index~ END
			END ELSE BEGIN
				LPF write_json_object INT_VAR size = size STR_VAR fields = ~index~ END
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION group_json
	INT_VAR 
		literal = 0
	STR_VAR
		json = ~~
		by = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF group_json 
				INT_VAR literal = literal 
				STR_VAR json = EVAL ~%json%~ by = EVAL ~%by%~
				RET res END
		END
	END
	
	
	
	
	
	
/*************************************************************************************
 ********************        Reading various file formats        ********************
 *************************************************************************************/ 



DEFINE_ACTION_FUNCTION read_json_file
	INT_VAR eval = 0
	STR_VAR file = ~~
	RET json
	BEGIN
		OUTER_SET size = SIZE_OF_FILE ~%file%~
		
		COPY ~%file%~ ~%MOD_FOLDER%~ //just read
			PATCH_IF eval THEN BEGIN
				EVALUATE_BUFFER
			END
			READ_ASCII 0 json (%size%)  
		BUT_ONLY_IF_IT_CHANGES
		
		LAF is_valid_json STR_VAR json = EVAL ~%json%~ RET is_json END
		ACTION_IF NOT is_json THEN BEGIN
			FAIL ~File %file% does not contain valid Json data: 
%json%~
		END
	END



DEFINE_ACTION_FUNCTION read_2da_as_json_array
	INT_VAR
		eval = 0
	STR_VAR 
		file = ~~
		comment = ~~
	RET size
	RET_ARRAY res
	BEGIN
		ACTION_CLEAR_ARRAY res
		LAF regexp_escape STR_VAR str = EVAL ~%comment%~ RET comment_rx = regexp END
		
		COPY ~%file%~ ~%MOD_FOLDER%/JSON4WEIDU-DELETEME.2da~
			PATCH_IF eval THEN BEGIN
				EVALUATE_BUFFER
			END
			SET size = 0 - 1
			REPLACE_EVALUATE CASE_SENSITIVE ~^.+$~ BEGIN
				PATCH_IF (comment STR_EQ ~~ 
				         OR ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%comment_rx%~)
					 AND ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%$~	 
				THEN BEGIN
					PATCH_IF size < 0 THEN BEGIN
						LPF split_string 
							INT_VAR nonempty = 1
							STR_VAR string = EVAL ~%MATCH0%~ separators = ~	 ~
							RET columns = size
							RET_ARRAY fields = res END
					END ELSE BEGIN
						LPF split_string
							INT_VAR nonempty = 1
							STR_VAR string = EVAL ~%MATCH0%~ separators = ~	 ~
							RET count = size
							RET_ARRAY values = res END
						PATCH_IF count > columns THEN BEGIN
							PATCH_FAIL ~data row has more columns than header (%columns%) in file %file%: 
%MATCH0%~
						END
						
						CLEAR_ARRAY dict
						PHP_EACH values AS col => value BEGIN
							TEXT_SPRINT name $fields(~%col%~)
							TEXT_SPRINT $dict(~%name%~) ~%value%~
						END
						LPF json_object STR_VAR dict = ~dict~ RET elem = res END
						TEXT_SPRINT $res(~%size%~) ~%elem%~
					END
					SET size += 1
				END
			END ~%MATCH0%~	
			
			PATCH_IF size <= 0 THEN BEGIN
				SET size = 0
				TEXT_SPRINT $res(~0~) ~~
			END
		BUT_ONLY_IF_IT_CHANGES
	END

	

DEFINE_PATCH_FUNCTION read_2da_as_json_array
	INT_VAR
		eval = eval
	STR_VAR
		file = ~~
		comment = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_2da_as_json_array
				INT_VAR eval = eval
				STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
				RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION read_2da_as_json
	INT_VAR
		eval = 0
	STR_VAR
		file = ~~
		comment = ~~
	RET res
	BEGIN
		LAF read_2da_as_json_array
			INT_VAR eval = eval
			STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
			RET size RET_ARRAY array = res END
		LAF concat
			INT_VAR size = size
			STR_VAR array = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
			RET res END			
	END
	
	
	
DEFINE_PATCH_FUNCTION read_2da_as_json
	INT_VAR
		eval = 0
	STR_VAR
		file = ~~
		comment = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_2da_as_json 
				INT_VAR eval = eval
				STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
				RET res END
		END
	END
			
		




DEFINE_ACTION_FUNCTION read_csv_as_json_array
	INT_VAR eval = eval
	STR_VAR 
		file = ~~
		comment = ~~
		separators = ~,~
	RET size
	RET_ARRAY res
	BEGIN
		ACTION_CLEAR_ARRAY res
		LAF regexp_escape STR_VAR str = EVAL ~%comment%~ RET comment_rx = regexp END
		
		ACTION_MATCH STRING_LENGTH ~%separators%~ WITH
			0 BEGIN
				OUTER_TEXT_SPRINT separator_rx ~%WHITESPACE_RX%~
			END
			1 WHEN separators STRING_CONTAINS_REGEXP ~[?\.*+]~ BEGIN
				OUTER_TEXT_SPRINT separator_rx ~\%separators%~
			END
			1 BEGIN
				OUTER_TEXT_SPRINT separator_rx ~%separators%~
			END
			DEFAULT
				OUTER_TEXT_SPRINT separator_rx ~[%separators%]~
		END
		
		COPY ~%file%~ ~%MOD_FOLDER%/JSON4WEIDU-DELETEME.csv~
			PATCH_IF eval THEN BEGIN
				EVALUATE_BUFFER
			END
			SET size = 0 - 1
			REPLACE_EVALUATE CASE_SENSITIVE ~^.+$~ BEGIN //for non-empty lines
				PATCH_IF (comment STR_EQ ~~ //skip whitespace and comment lines
				         OR ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%comment_rx%~)
					 AND ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%$~	 
				THEN BEGIN
					PATCH_IF size < 0 THEN BEGIN
						//first line, treat it as a header with names for the columns
						LPF split_string 
							INT_VAR nonempty = 1
							STR_VAR 
								string = EVAL ~%MATCH0%~ 
								regexp = EVAL ~%separator_rx%~
							RET columns = size
							RET_ARRAY fields = res END
						PHP_EACH values AS col => name BEGIN
							LPF trim_string STR_VAR string = EVAL ~%name%~ RET name = res END
							TEXT_SPRINT $columns(~%col%~) ~%name%~
						END
						
					END ELSE BEGIN
						LPF split_string
							INT_VAR nonempty = 1
							STR_VAR 
								string = EVAL ~%MATCH0%~ 
								regexp = EVAL ~%separator_rx%~
							RET count = size
							RET_ARRAY values = res END
						PATCH_IF count > columns THEN BEGIN
							PATCH_FAIL ~data row has more columns than header (%columns%) in file %file%: 
%MATCH0%~
						END
						
						CLEAR_ARRAY dict
						PHP_EACH values AS col => value BEGIN
							LPF trim_string STR_VAR string = EVAL ~%value%~ RET value = res END
							PATCH_IF NOT value STR_EQ ~~ THEN BEGIN
								TEXT_SPRINT name $fields(~%col%~)
								TEXT_SPRINT $dict(~%name%~) ~%value%~
							END
						END
						
						LPF json_object STR_VAR dict = ~dict~ RET elem = res END
						TEXT_SPRINT $res(~%size%~) ~%elem%~
					END
					SET size += 1
				END
			END ~%MATCH0%~	
			
			PATCH_IF size <= 0 THEN BEGIN
				SET size = 0
				TEXT_SPRINT $res(~0~) ~~
			END
		BUT_ONLY_IF_IT_CHANGES
	END

	

DEFINE_PATCH_FUNCTION read_csv_as_json_array
	INT_VAR
		eval = 0
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_csv_as_json_array
				INT_VAR eval = eval
				STR_VAR 
					file = EVAL ~%file%~ 
					comment = EVAL ~%comment%~
					separators = EVAL ~%separators%~
				RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION read_csv_as_json
	INT_VAR
		eval = 0
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET res
	BEGIN
		LAF read_csv_as_json_array
			INT_VAR eval = eval
			STR_VAR 
				file = EVAL ~%file%~ 
				comment = EVAL ~%comment%~
				separators = EVAL ~%separators%~
			RET size RET_ARRAY array = res END
		LAF concat
			INT_VAR size = size
			STR_VAR array = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
			RET res END			
	END
	
	
	
DEFINE_PATCH_FUNCTION read_csv_as_json
	INT_VAR 
		eval = 0
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_csv_as_json 
				INT_VAR eval = eval
				STR_VAR 
					file = EVAL ~%file%~ 
					comment = EVAL ~%comment%~
					separators = EVAL ~%separators%~
				RET res END
		END
	END		





END //JSON4WEIDU	
			