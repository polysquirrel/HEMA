ACTION_IF NOT VARIABLE_IS_SET JSON4WEIDU THEN BEGIN
OUTER_TEXT_SPRINT JSON4WEIDU ~JSON4WEIDU~ 

INCLUDE ~%MOD_FOLDER%/stringutil.tpa~


/*************************************************************************************
 ********************                                             ********************
 ********************   Functions for working with json strings   ********************
 ********************                                             ********************
 *************************************************************************************/ 


OUTER_TEXT_SPRINT JSON_PROPERTY_SEPARATOR ~.~


/** Regexp matching any sequence of '\' terminated by a character other than '"' and '\', 
  * or an odd sequence of '\' terminated by '"'. */
OUTER_TEXT_SPRINT JSON_STRING_ATOM_RX ~\(\\*[^\"]\|\([^\]\\\(\\\\\)*"\)\)~
/** Any string surrounded by a pair of '"' characters, in which all '"' are escaped with a '\'.*/
OUTER_TEXT_SPRINT JSON_STRING_RX ~"\(\(\\\(\\\\\)*"\)?\(%JSON_STRING_ATOM_RX%*\)\(\(\\\\\)*\)\)"~ 

OUTER_TEXT_SPRINT JSON_NULL ~null~

OUTER_TEXT_SPRINT JSON_TRUE ~true~
OUTER_TEXT_SPRINT JSON_FALSE ~false~

OUTER_SET MAX_INT = BIT31 - 1 //2147483647
 




DEFINE_PATCH_MACRO expect_valid_json BEGIN //TODO
	LPF is_valid_json STR_VAR json = EVAL ~%json%~ RET is_json END
	PATCH_IF NOT is_json THEN BEGIN
		PATCH_FAIL ~Invalid json: <<%json%>>~
	END
END



/*************************************************************************************
 ********************     String-related util functions           ********************
 *************************************************************************************/ 



/** Trims all whitespace from the front of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json_front BEGIN
	LAF trim_string_front STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the front of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json_front BEGIN
	LPF trim_string_front STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the back of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json_back BEGIN
	LAF trim_string_back STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from the back of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json_back BEGIN
	LPF trim_string_back STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from both ends of a string variable %json%. */
DEFINE_ACTION_MACRO trim_json BEGIN
	LAF trim_string STR_VAR string = EVAL ~%json%~ RET json = res END
END



/** Trims all whitespace from both ends of a string variable %json%. */
DEFINE_PATCH_MACRO trim_json BEGIN
	LPF trim_string STR_VAR string = EVAL ~%json%~ RET json = res END
END
 




/** Replaces all '"' and '\' characters in the input string by '\"' and '\\' respectively. */
DEFINE_ACTION_FUNCTION json_escape_str
	STR_VAR	str = ~~
	RET	res 
	BEGIN
		OUTER_PATCH_SAVE res ~%str%~ BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
			REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		END
	END
 
 

/** Replaces all '"' and '\' characters in the input string by '\"' and '\\' respectively. */ 
 DEFINE_PATCH_FUNCTION json_escape_str
	STR_VAR str = ~~
	RET res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_escape_str STR_VAR str = EVAL ~%str%~ RET res END
		END
	END



	

 
/*************************************************************************************
 ********************    Writing json to the patch buffer        ********************
 *************************************************************************************/ 



DEFINE_PATCH_FUNCTION write_json_boolean
	INT_VAR 
		offset = 0 - 1
		boolean = 0
	STR_VAR
		json = ~~
	RET 
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		PATCH_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			SET boolean = 1
		END ELSE PATCH_IF ~%json%~ STR_EQ ~false~ THEN BEGIN
			SET boolean = 0
		END ELSE BEGIN
			PATCH_FAIL ~write_json_boolean: argument json=<<%json%> is not a valid json boolean.~
		END
		
		PATCH_IF boolean THEN BEGIN
			INSERT_BYTES offset 4
			WRITE_ASCII offset ~true~
			SET offset += 4
		END ELSE BEGIN
			INSERT_BYTES offset 5
			WRITE_ASCII offset ~false~
			SET offset += 5
		END
	END



DEFINE_PATCH_FUNCTION write_json_number
	INT_VAR
		offset = 0 - 1
		number = 0
	RET 
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		SET str = ~%number%~
		SET len = STRING_LENGTH ~%str%~
		INSERT_BYTES offset len
		WRITE_ASCIIE offset ~%str%~ 		
		SET offset += len
	END



DEFINE_PATCH_FUNCTION write_json_string
	INT_VAR 
		offset = 0 - 1
	STR_VAR 
		string = ~~
		json = ~~
	RET
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH
		END
		PATCH_IF ~%json%~ STR_EQ ~~ THEN BEGIN //write %string% to the buffer after transforming it to json
			INNER_PATCH_SAVE escaped ~%string%~ BEGIN
				REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~\~ ~\\\\~
				REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~"~ ~\"~
			END 
			SET length = STRING_LENGTH ~%escaped%~
			INSERT_BYTES offset (length + 2)
			WRITE_ASCII offset ~"~
			WRITE_ASCIIE (offset + 1) ~%escaped%~
			WRITE_ASCII (offset + 1 + length) ~"~		
			SET offset += length + 2

		END ELSE BEGIN
			LPF is_json_string STR_VAR json = EVAL ~%json%~ RET is_string END
			PATCH_IF NOT is_string THEN BEGIN
				PATCH_FAIL ~write_json_string: argument json=<<%json%>> is not a json string.~
			END
			SET length = STRING_LENGTH ~%json%~
			INSERT_BYTES offset length
			WRITE_ASCIIE offset ~%json%~
			SET offset += length
		END
	END
	
	

DEFINE_PATCH_FUNCTION write_as_json
	INT_VAR
		offset = 0 - 1
	STR_VAR
		value = ~~
	RET
		offset
	BEGIN
		PATCH_IF IS_AN_INT ~%value%~ THEN BEGIN
			LPF write_json_number INT_VAR offset = offset number = value RET offset END
		END ELSE BEGIN
			LPF write_json_string 
				INT_VAR offset = offset 
				STR_VAR string = EVAL ~%value%~ 
				RET offset
			END
		END
	END
	
	

DEFINE_PATCH_FUNCTION write_json_array 
	INT_VAR
		offset = 0 - 1
		size = 2147483647
	STR_VAR
		rawarray = ~~
		array = ~~
	RET
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH	
		END 
		PATCH_IF size <= 0 THEN BEGIN
			INSERT_BYTES offset 2
			WRITE_ASCII offset ~[]~
			SET offset += 2
		
		END ELSE BEGIN			
			INSERT_BYTES offset 1
			WRITE_ASCII offset ~[~
			SET offset += 1
			SET i = 0
			
			PATCH_IF NOT ~%rawarray%~ STR_EQ ~~ THEN BEGIN
				PHP_EACH ~%rawarray%~ AS _ => json BEGIN
					PATCH_IF i < size THEN BEGIN
						PATCH_IF i THEN BEGIN
							INSERT_BYTES offset 2
							WRITE_ASCII offset ~, ~
							SET offset += 2
						END
						
						LPF write_json 
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%json%~
							RET offset
						END	
					END
					SET i += 1
				END
			
			END ELSE PATCH_IF NOT ~%array%~ STR_EQ ~~ THEN BEGIN
				PHP_EACH ~%array%~ AS _ => value BEGIN
					PATCH_IF i < size THEN BEGIN
						PATCH_IF i THEN BEGIN
							INSERT_BYTES offset 2
							WRITE_ASCII offset ~, ~
							SET offset += 2
						END
						
						LPF write_as_json 
							INT_VAR offset = offset 
							STR_VAR value = EVAL ~%value%~
							RET offset
						END
					END
					SET i += 1
				END
			END
			
			INSERT_BYTES offset 1
			WRITE_ASCII offset ~]~
			SET offset += 1
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION write_json_object 
	INT_VAR 
		offset = 0 - 1
		size = 2147483647
	STR_VAR 
		rawfields = ~~
		fields = ~~
		dict = ~~
	RET 
		offset
	BEGIN
		PATCH_IF offset < 0 THEN BEGIN			
			SET offset = BUFFER_LENGTH	
		END

		INSERT_BYTES offset 1
		WRITE_ASCII offset ~{~
		SET offset += 1
		SET i = 0
		
		TEXT_SPRINT array ~~
		SET format = 0
		PATCH_IF NOT ~%rawfields%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%rawfields%~
			SET format = 1
		END ELSE PATCH_IF NOT ~%fields%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%fields%~ 
			SET format = 2
		END ELSE PATCH_IF NOT ~%dict%~ STR_EQ ~~ THEN BEGIN
			TEXT_SPRINT array ~%dict%~
			SET format = 3
		END
		
		PATCH_IF format AND size >= 0 THEN BEGIN
			PHP_EACH ~%array%~ AS field => value BEGIN
				PATCH_IF i < size THEN BEGIN 
					PATCH_IF i THEN BEGIN
						INSERT_BYTES offset 2
						WRITE_ASCII offset ~, ~
						SET offset += 2
					END
					
					PATCH_IF format == 1 THEN BEGIN
						LPF write_json_string 
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%field%~ 
							RET offset END
					END ELSE BEGIN
						LPF write_json_string
							INT_VAR offset = offset
							STR_VAR string = EVAL ~%field%~
							RET offset END
					END
						
					INSERT_BYTES offset 2 
					WRITE_ASCII offset ~: ~
					SET offset += 2
					
					PATCH_IF format == 3 THEN BEGIN
						LPF write_as_json
							INT_VAR offset = offset
							STR_VAR value = EVAL ~%value%~
							RET offset END
					END ELSE BEGIN
						LPF write_json
							INT_VAR offset = offset
							STR_VAR json = EVAL ~%value%~
							RET offset END
					END
				END
				SET i += 1
			END
		END
		
		INSERT_BYTES offset 1
		WRITE_ASCII offset ~}~
		SET offset += 1
	END
	


DEFINE_PATCH_FUNCTION write_json
	INT_VAR 
		offset = 0 - 1
	STR_VAR
		json = ~~
	RET 
		offset
	BEGIN
		LPM expect_valid_json
		SET length = STRING_LENGTH ~%json%~
		INSERT_BYTES offset length
		WRITE_ASCIIE offset ~%json%~
		SET offset += length
	END






/*************************************************************************************
 ********************        Json constructor functions           ********************
 *************************************************************************************/ 



/** Returns json boolean representation ('true'/'false') based on whether the given int is non-zero. */
DEFINE_ACTION_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		ACTION_IF boolean THEN BEGIN
			OUTER_TEXT_SPRINT res ~true~
		END ELSE BEGIN
			OUTER_TEXT_SPRINT res ~false~
		END
	END
	
	

/** Returns json boolean representation ('true'/'false') based on whether the given int is non-zero. */	
DEFINE_PATCH_FUNCTION json_boolean
	INT_VAR boolean = 0
	RET res
	BEGIN
		PATCH_IF boolean THEN BEGIN
			TEXT_SPRINT res ~true~
		END ELSE BEGIN
			TEXT_SPRINT res ~false~
		END
	END
	
	

/** Returns json number representation of an integer. This is most basic string formatting. */	
DEFINE_ACTION_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		OUTER_TEXT_SPRINT res ~%number%~
	END
	
	

/** Returns json number representation of an integer. This is most basic string formatting. */	
DEFINE_PATCH_FUNCTION json_number
	INT_VAR number = 0
	RET res
	BEGIN
		TEXT_SPRINT res ~%number%~
	END
	
	

/** Formats the given string variable %string% for inclusion in json data. All '"' and '\'	
  * characters are preceeded by a '\' and the whole string is surrounded in a pair of '"'.
  */
DEFINE_ACTION_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN 
		//LAF json_escape_str STR_VAR str = EVAL ~%string%~ RET res END
		OUTER_PATCH_SAVE res ~%string%~ BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH ~\~ ~\\\\~ 
			REPLACE_TEXTUALLY EXACT_MATCH ~"~ ~\"~
		END
		OUTER_TEXT_SPRINT res ~"%res%"~
	END
	
	

/** Formats the given string variable %string% for inclusion in json data. All '"' and '\'	
  * characters are preceeded by a '\' and the whole string is surrounded in a pair of '"'.
  */	
DEFINE_PATCH_FUNCTION json_string
	STR_VAR string = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_string STR_VAR string = EVAL ~%string%~ RET res END
		END
	END

	

DEFINE_ACTION_FUNCTION to_json
	STR_VAR value = ~~
	RET res
	BEGIN
		ACTION_IF IS_AN_INT ~%value%~ THEN BEGIN
			OUTER_TEXT_SPRINT res ~%value%~
		END ELSE BEGIN
			LAF json_string STR_VAR string = EVAL ~%value%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION to_json
	STR_VAR value = ~~
	RET res 
	BEGIN
		PATCH_IF IS_AN_INT ~%value%~ THEN BEGIN
			TEXT_SPRINT res ~%value%~
		END ELSE BEGIN
			LPF json_string STR_VAR string = EVAL ~%value%~ RET res END
		END
	END
	
	
	
/** Formats the given weidu array $%array% or $%rawarray% for inclusion in json data. Elements of 
  * the array must be valid json strings themselves, which are concatenated, separated by
  * ', ' and surrounded by a matching pair of brackets '[' and ']'.
  * Use the %rawarray% argument for arrays which elements already are json values (including composites) 
  * themselves and %array% for arrays of weidu strings (and ints) which need converting to json before
  * formatting.
  */	
DEFINE_ACTION_FUNCTION json_array
	INT_VAR 
		/** If specified, only that many first elements of the array are included.
		  * Useful when other functions return non-empty arrays with explicitly specified
		  * zero size due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of an array construct containing the json elements to include. */
		rawarray = ~~
		/** Name of an array construct containing the values to include. 
		  * All elements will be converted to json as per to_json. */
		array = ~~
	RET 
		/** A string containing a json array with the given elements. */	
		res
	BEGIN
		OUTER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_array 
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawarray = EVAL ~%rawarray%~
					array = EVAL ~%array%~
			END
		END
	END
	
	
	
/** Formats the given weidu array $%array% or $%rawarray% for inclusion in json data. Elements of 
  * the array must be valid json strings themselves, which are concatenated, separated by
  * ', ' and surrounded by a matching pair of brackets '[' and ']'.
  * Use the %rawarray% argument for arrays which elements already are json values (including composites) 
  * themselves and %array% for arrays of weidu strings (and ints) which need converting to json before
  * formatting.
  */	
DEFINE_PATCH_FUNCTION json_array
	INT_VAR 
		/** If specified, only that many first elements of the array are included.
		  * Useful when other functions return non-empty arrays with explicitly specified
		  * zero size due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of an array construct containing the json elements to include. */
		rawarray = ~~
		/** Name of an array construct containing the values to include. 
		  * All elements will be converted to json as per to_json. */
		array = ~~
	RET 
		/** A string containing a json array with the given elements. */	
		res
	BEGIN
		INNER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_array 
				INT_VAR offset = 0 size = size
				STR_VAR rawarray = EVAL ~%rawarray%~ array = EVAL ~%array%~
			END
		END
	END



/** Formats an associative array as a json object. The keys are names of the fields of
  * the object while their associated values the field values. The exacTheir
  * handling depends on which of the input parameters %rawfields%, %fields% and %dict% is specified. 
  * Any parameter, when present, must contain a name of a json weidu construct. The keys of %rawfields%
  * must be valid json strings ready to include verbatim in the result; the keys of %fields% and %dict%
  * are treated as string values and formatted as json strings as per json_string before writing.
  * The values of %rawfields% and %fields% must be valid json values (including composites), while
  * the values of %dict% are treated as weidu values (strings or ints) and formatted accordingly:
  * if an element is a valid integer, it is written as a number. Otherwise it is formatted as a json
  * string value.
  */  
DEFINE_ACTION_FUNCTION json_object
	INT_VAR 
		/** If specified, only that many first fields from the array are included.
		  * Useful when another function returns a non-empty array with explicitly 
		  * specified zero length due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of a weidu array containing key-value pairs matching field names (as valid json strings)
		  * with their json values. */
		rawfields = ~~
		/** Name of a weidu array containing key-value pairs matching field names (as weidu strings)
		  * with their json values. */
		fields = ~~
		/** Name of a weidu array containing key-value pairs matching fields names (as weidu strings)
		  * with their weidu values. */
		dict = ~~
	RET 
		/** Returned string representation of the formatted json object. */
		res	
	BEGIN
		OUTER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_object
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawfields = EVAL ~%rawfields%~
					fields = EVAL ~%fields%~
					dict = EVAL ~%dict%~
			END
		END
	END
	
	
	
/** Formats an associative array as a json object. The keys are names of the fields of
  * the object while their associated values the field values. The exacTheir
  * handling depends on which of the input parameters %rawfields%, %fields% and %dict% is specified. 
  * Any parameter, when present, must contain a name of a json weidu construct. The keys of %rawfields%
  * must be valid json strings ready to include verbatim in the result; the keys of %fields% and %dict%
  * are treated as string values and formatted as json strings as per json_string before writing.
  * The values of %rawfields% and %fields% must be valid json values (including composites), while
  * the values of %dict% are treated as weidu values (strings or ints) and formatted accordingly:
  * if an element is a valid integer, it is written as a number. Otherwise it is formatted as a json
  * string value.
  */  
DEFINE_PATCH_FUNCTION json_object
	INT_VAR 
		/** If specified, only that many first fields from the array are included.
		  * Useful when another function returns a non-empty array with explicitly 
		  * specified zero length due to the weidu limitation on array initialization.
		  */
		size = 2147483647
	STR_VAR 
		/** Name of a weidu array containing key-value pairs matching field names (as valid json strings)
		  * with their json values. */
		rawfields = ~~
		/** Name of a weidu array containing key-value pairs matching field names (as weidu strings)
		  * with their json values. */
		fields = ~~
		/** Name of a weidu array containing key-value pairs matching fields names (as weidu strings)
		  * with their weidu values. */
		dict = ~~
	RET 
		/** Returned string representation of the formatted json object. */
		res	
	BEGIN
		INNER_PATCH_SAVE res ~~ BEGIN
			LPF write_json_object
				INT_VAR offset = 0 size = size
				STR_VAR 
					rawfields = EVAL ~%rawfields%~
					fields = EVAL ~%fields%~
					dict = EVAL ~%dict%~
			END
		END
	END






	
/*************************************************************************************
 ********************    Internal json parsing functions          ********************
 *************************************************************************************/ 
	
	

DEFINE_PATCH_MACRO skip_whitespace_before_json BEGIN
	PATCH_IF offset < 0 THEN BEGIN
		SET offset = cursor
	END
	SET skipped = 0
	LPF skip_buffer_whitespace INT_VAR offset = offset RET start = offset srclength next END
END



DEFINE_PATCH_FUNCTION skip_json_null 
	INT_VAR offset = 0 - 1
	RET offset skipped		
	BEGIN
		LPM skip_whitespace_before_json
		
		PATCH_IF start < srclength - 4 THEN BEGIN
			READ_ASCII start val (4)
			PATCH_IF ~%val%~ STR_EQ ~null~ THEN BEGIN
				SET skipped = start + 4 - offset
				SET offset = start + 4 
			END
		END
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_boolean
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json

		PATCH_IF start <= srclength - 5 AND ~%next%~ STR_EQ ~f~ THEN BEGIN
			READ_ASCII start val (5)
			PATCH_IF ~%val%~ STR_EQ ~false~ THEN BEGIN
				SET skipped = start + 5 - offset
				SET offset = start + 5
			END
		END ELSE PATCH_IF start <= srclength - 4 AND ~%next%~ STR_EQ ~t~ THEN BEGIN
			READ_ASCII start val (4)
			PATCH_IF ~%val%~ STR_EQ ~true~ THEN BEGIN
				SET skipped = start + 4 - offset
				SET offset = start + 4
			END
		END 
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_number
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		
		TEXT_SPRINT digits ~0123456789~

		PATCH_MATCH ~%next%~ WITH 
			~0~ BEGIN
				SET i = start + 1
				PATCH_IF i < srclength THEN BEGIN				
					READ_ASCII i next (1)
					PATCH_MATCH ~%next%~ WITH
						~x~ ~X~ BEGIN //hexadecimal value
							TEXT_SPRINT digits ~0123456789AaBbCcDdEeFf~
							SET i += 1						
							SET start = i
						END
						~o~ ~O~ BEGIN //octal value
							TEXT_SPRINT digits ~01234567~
							SET i += 1
							SET start = i
						END
						~b~ ~B~ BEGIN //binary value
							TEXT_SPRINT digits ~01~
							SET i += 1
							SET start = i
						END
						DEFAULT //decimal value							
					END
					READ_ASCII i next (1)
				END
			END
			~+~ ~-~ BEGIN
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset next END
				SET i = start
			END
			DEFAULT
				SET i = start
		END

		PATCH_IF i < srclength THEN BEGIN		
			SET continue = INDEX(CASE_SENSITIVE EXACT_MATCH ~%next%~ ~%digits%~) >= 0
			WHILE i < srclength - 1 AND continue BEGIN
				SET i += 1
				READ_ASCII i next (1)				
				SET continue = INDEX(CASE_SENSITIVE EXACT_MATCH ~%next%~ ~%digits%~) >= 0

			END
			PATCH_IF continue THEN BEGIN
				SET i += 1
			END
		END

		PATCH_IF i > start THEN BEGIN
			SET skipped = i - offset
			SET offset = i
		END		
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_string
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		
		PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN
			SET i = start + 1
			TEXT_SPRINT next ~~
			
			WHILE (i < srclength AND NOT ~%next%~ STR_EQ ~"~) BEGIN //let's find the closing '"'					
				READ_ASCII i next (1)
				SET j = i //advance over all following '\' checking parity
				WHILE (j < srclength - 1 AND ~%next%~ STR_EQ ~\~) BEGIN
					SET j += 1
					READ_ASCII j next (1)
				END
				PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //check if it's escaped
					PATCH_IF (j - i) MODULO 2 == 1 THEN BEGIN //escaped
						TEXT_SPRINT next ~~ //'hide' the '"'
					END
				END
				SET i = j + 1
			END //%i% - 1 is the index of closing '"' or i==srclength => no closing '"'
			
			PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //yay!
				SET skipped = i - offset
				SET offset = i
			END
		END	
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_array
	INT_VAR offset = 0 - 1
	RET offset skipped size
	BEGIN
		LPM skip_whitespace_before_json			
		SET size = 0
		
		PATCH_IF ~%next%~ STR_EQ ~[~ THEN BEGIN
			LPF skip_json INT_VAR offset = start + 1 RET i = offset skipped END
			LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
			PATCH_IF skipped THEN BEGIN
				SET size += 1
			END
			WHILE skipped AND ~%next%~ STR_EQ ~,~ BEGIN
				LPF skip_json INT_VAR offset = i + 1 RET i = offset skipped END
				PATCH_IF skipped THEN BEGIN
					LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
					SET size += 1
				END 					
			END
			
			PATCH_IF ~%next%~ STR_EQ ~]~ THEN BEGIN
				SET skipped = i + 1 - offset 
				SET offset = i + 1
			END ELSE BEGIN
				SET skipped = 0
				SET size = 0
			END
		END
	END
	
	

DEFINE_PATCH_FUNCTION skip_json_object_field 
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPF skip_json_string INT_VAR offset = offset RET i = offset skipped END
		LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
			
		PATCH_IF skipped AND ~%next%~ STR_EQ ~:~ THEN BEGIN
			LPF skip_json INT_VAR offset = i + 1 RET i = offset skipped END
			
			PATCH_IF skipped THEN BEGIN
				SET skipped = i - offset
				SET offset = i
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION skip_json_object
	INT_VAR offset = 0 - 1
	RET offset skipped size
	BEGIN
		LPM skip_whitespace_before_json
		SET size = 0
		
		PATCH_IF ~%next%~ STR_EQ ~{~ THEN BEGIN
			LPF skip_json_object_field INT_VAR offset = start + 1 RET i = offset skipped END
			LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
			PATCH_IF skipped THEN BEGIN
				SET size += 1
			END
			
			WHILE skipped AND ~%next%~ STR_EQ ~,~ BEGIN
				LPF skip_json_object_field INT_VAR offset = i + 1 RET i = offset skipped END
				PATCH_IF skipped THEN BEGIN
					LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
					SET size += 1
				END
			END
			
			PATCH_IF ~%next%~ STR_EQ ~}~ THEN BEGIN
				SET skipped = i + 1 - offset
				SET offset = i + 1
			END ELSE BEGIN
				SET skipped = 0
			END
		END
	END



DEFINE_PATCH_FUNCTION skip_json
	INT_VAR offset = 0 - 1
	RET offset skipped
	BEGIN
		LPM skip_whitespace_before_json
		
		PATCH_MATCH ~%next%~ WITH
			~"~ BEGIN
				LPF skip_json_string INT_VAR offset = start RET offset skipped END
			END
			~\[~ BEGIN
				LPF skip_json_array INT_VAR offset = start RET offset skipped END
			END
			~{~ BEGIN
				LPF skip_json_object INT_VAR offset = start RET offset skipped END
			END
			~t~ ~f~ BEGIN
				LPF skip_json_boolean INT_VAR offset = start RET offset skipped END
			END
			~n~ BEGIN
				LPF skip_json_null INT_VAR offset = start RET offset skipped END
			END
			DEFAULT 
				LPF skip_json_number INT_VAR offset = start RET offset skipped END
		END
	END

 	
	
	
		
	
/*************************************************************************************
 ********************    Reading json from the patch buffer       ********************
 *************************************************************************************/ 



DEFINE_PATCH_MACRO read_skipped_json BEGIN
	PATCH_IF skipped THEN BEGIN
		READ_ASCII start json (end - start)
		SET offset = end
	END ELSE BEGIN
		LPF next_buffer_token 
			INT_VAR offset = start
			STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
			RET json = token END		
		PATCH_FAIL ~Invalid json or unexpected data type at #%start%. Reading started with <<%json%>>.~
	END
END



DEFINE_PATCH_FUNCTION read_json_boolean
	INT_VAR	offset = 0 - 1
	RET offset res
	BEGIN
		LPM skip_whitespace_before_json
		LPF skip_json_boolean INT_VAR offset = start RET end = offset skipped END
		LPM read_skipped_json
		PATCH_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			SET res = 1
		END ELSE BEGIN
			SET res = 0
		END
	END




DEFINE_PATCH_FUNCTION read_json_number
	INT_VAR offset = 0 - 1
	RET offset res 
	BEGIN 
		LPM skip_whitespace_before_json
		LPF skip_json_number INT_VAR offset = start RET end = offset skipped END

		SET signum = 1
		PATCH_MATCH ~%next%~ WITH
			~+~ BEGIN
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset END
			END
			~-~ BEGIN
				SET signum = 0 - 1
				LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET start = offset END
			END
			DEFAULT
		END
		LPM	read_skipped_json
		SET res = signum * json
	END
	
	

DEFINE_PATCH_FUNCTION read_json_string
	INT_VAR offset = 0 - 1
	RET offset res
	BEGIN 
		LPM skip_whitespace_before_json

		PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN
			SET size = 0
			SET i = start + 1
			TEXT_SPRINT next ~~
			
			WHILE (i < srclength AND NOT ~%next%~ STR_EQ ~"~) BEGIN //let's find the closing '"'					
				READ_ASCII i next (1)
				SET j = i //advance over all following '\' checking parity
				WHILE (j < srclength - 1 AND ~%next%~ STR_EQ ~\~) BEGIN
					PATCH_IF (j - i) REM 2 == 1 THEN BEGIN
						TEXT_SPRINT $chars(~%size%~) ~%next%~
						SET size += 1
					END
					SET j += 1
					READ_ASCII j next (1)
				END
				PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //check if it's escaped
					PATCH_IF (j - i) REM 2 == 1 THEN BEGIN //escaped
						TEXT_SPRINT next ~~ //'hide' the '"'
						TEXT_SPRINT $chars(~%size%~) ~"~
						SET size += 1
					END
				END ELSE BEGIN
					TEXT_SPRINT $chars(~%size%~) ~%next%~
					SET size += 1
				END
				SET i = j + 1
			END //%i% - 1 is the index of closing '"' or i==srclength => no closing '"'
			
			PATCH_IF ~%next%~ STR_EQ ~"~ THEN BEGIN //yay!
				SET offset = i
				LPF concat STR_VAR arrayvar = ~chars~ RET res END
			END ELSE BEGIN
				PATCH_FAIL ~read_json_string: no closing '"' for opening '"' at #%offset%~
			END
		END	ELSE BEGIN
			PATCH_FAIL ~read_json_string: at #%offset% expected opening '"', got: '%next%'~
		END

	END
	
	

DEFINE_PATCH_FUNCTION read_json_value
	INT_VAR offset = 0 - 1
	RET offset res
	BEGIN
		LPM skip_whitespace_before_json
		PATCH_MATCH ~%next%~ WITH
			~"~ BEGIN
				LPF read_json_string INT_VAR offset = start RET offset res END
			END
			~t~ ~f~ BEGIN
				LPF read_json_boolean INT_VAR offset = start RET offset res END
			END
			~[+-0123456789]~ BEGIN
				LPF read_json_number INT_VAR offset = start RET offset res END
			END
			DEFAULT 
				LPF next_buffer_token 
					INT_VAR offset = start
					STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
					RET json = token END		
				PATCH_FAIL ~read_json_value: can't convert <<%json%>> to a weidu variable; source offset=%start%.~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION read_raw_json_array
	INT_VAR offset = 0 - 1
	RET offset size
	RET_ARRAY res
	BEGIN
		LPM skip_whitespace_before_json			
		SET size = 0
		
		PATCH_IF ~%next%~ STR_EQ ~[~ THEN BEGIN
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset next END
			
			PATCH_IF NOT ~%next%~ STR_EQ ~]~ THEN BEGIN
				LPF read_json INT_VAR offset = offset RET offset json END
				TEXT_SPRINT $res(~0~) ~%json%~ 
				SET size += 1
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset next END
				
				WHILE ~%next%~ STR_EQ ~,~ BEGIN
					LPF read_json INT_VAR offset = offset + 1 RET offset json END
					TEXT_SPRINT $res(~%size%~) ~%json%~
					SET size += 1
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset next END
				END
			END

			PATCH_IF NOT ~%next%~ STR_EQ ~]~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~read_raw_json_array: expected ',' or ']', got '%next%' at #%offset% following '%prefix%'.~
			END
			SET offset += 1
			
			PATCH_IF size == 0 THEN BEGIN
				TEXT_SPRINT $res(~~) ~<empty array; check size before accessing>~
			END
		END ELSE BEGIN
			PATCH_FAIL ~read_raw_json_array: expected '[', got '%next%' at #%start%.~
		END
		
	END
	
	
	
DEFINE_PATCH_FUNCTION read_json_array
	INT_VAR offset = 0 - 1
	RET offset size
	RET_ARRAY res
	BEGIN
		LPF read_raw_json_array INT_VAR offset = offset RET offset size RET_ARRAY res END
		FOR (i = 0; i < size; ++i) BEGIN
			TEXT_SPRINT json $res(~%i%~)
			LPF json_value STR_VAR json = EVAL ~%json%~ RET val = res END
			TEXT_SPRINT $res(~%i%~) ~%val%~
		END
	END
	
	

DEFINE_PATCH_FUNCTION read_raw_json_object_field 
	INT_VAR offset = 0 - 1
	RET offset field value
	BEGIN
		LPM skip_whitespace_before_json
		LPF skip_json_string INT_VAR offset = start RET i = offset skipped END

		PATCH_IF NOT skipped THEN BEGIN
			LPF next_buffer_token 
				INT_VAR offset = offset
				STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
				RET token END		
			PATCH_FAIL ~read_raw_json_object_field: expected field name as string at #%offset%, got '%token%'.~
		END
		READ_ASCII start field (skipped)
		LPF skip_buffer_whitespace INT_VAR offset = i RET i = offset next END
			
		PATCH_IF NOT ~%next%~ STR_EQ ~:~ THEN BEGIN
			PATCH_FAIL ~read_raw_json_object_field: missing ':' after field %field% at #%i%.~
		END
		LPF read_json INT_VAR offset = i + 1 RET offset value = json END

	END
	
	

	
DEFINE_PATCH_FUNCTION read_raw_json_object_fields
	INT_VAR offset = 0 - 1
	RET offset size
	RET_ARRAY res
	BEGIN
		LPM skip_whitespace_before_json
		SET size = 0
		PATCH_IF ~%next%~ STR_EQ ~{~ THEN BEGIN
			LPF skip_buffer_whitespace INT_VAR offset = start + 1 RET offset next END
			
			PATCH_IF NOT ~%next%~ STR_EQ ~}~ THEN BEGIN				
				LPF read_raw_json_object_field INT_VAR offset = offset RET offset field value END
				TEXT_SPRINT $res(~%field%~) ~%value%~
				SET size += 1
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset next END
				
				WHILE ~%next%~ STR_EQ ~,~ BEGIN
					LPF read_raw_json_object_field INT_VAR offset = offset + 1 RET offset field value END
					TEXT_SPRINT $res(~%field%~) ~%value%~
					SET size += 1
					LPF skip_buffer_whitespace INT_VAR offset = offset RET offset next END
				END
			END

			PATCH_IF NOT ~%next%~ STR_EQ ~}~ THEN BEGIN
				READ_ASCII start prefix (offset - start)
				PATCH_FAIL ~read_raw_json_object_fields: expected ',' or '}'; got '%next%' at #%offset% following '%prefix%'.~
			END 
			SET offset += 1
			
			PATCH_IF NOT size THEN BEGIN 
				TEXT_SPRINT $res(~""~) ~"<empty object; check size before accessing>"~
			END
		END ELSE BEGIN
			PATCH_FAIL ~read_raw_json_object_fields: expected '{', got '%next%' at #%start%.~
		END
	END



DEFINE_PATCH_FUNCTION read_json_object_fields
	INT_VAR offset = 0 - 1
	RET offset size
	RET_ARRAY res
	BEGIN
		LPF read_raw_json_object_fields INT_VAR offset = offset RET offset size RET_ARRAY fields = res END
		PATCH_IF NOT size THEN BEGIN
			TEXT_SPRINT $res(~~) ~<empty object; check size before accessing>~
		END ELSE BEGIN
			PHP_EACH fields AS field => value BEGIN
				LPF json_string_value STR_VAR json = EVAL ~%field%~ RET name = res END
				TEXT_SPRINT $res(~%name%~) ~%value%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION read_json_as_dict
	INT_VAR offset = 0 - 1
	RET offset size
	RET_ARRAY res
	BEGIN
		LPF read_raw_json_object_fields INT_VAR offset = offset RET offset size RET_ARRAY fields = res END
		PATCH_IF NOT size THEN BEGIN
			TEXT_SPRINT $res(~~) ~<empty object; check size before accessing>~
		END ELSE BEGIN
			PHP_EACH fields AS field => json BEGIN
				LPF json_string_value STR_VAR json = EVAL ~%field%~ RET name = res END
				LPF json_value STR_VAR json = EVAL ~%json%~ RET value = res END
				TEXT_SPRINT $res(~%name%~) ~%value%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION read_json	
	INT_VAR offset = 0 - 1
	RET offset json
	BEGIN
		LPM skip_whitespace_before_json
		LPF skip_json INT_VAR offset = start RET end = offset skipped END
		LPM read_skipped_json		
	END
	
	
	
	

/*************************************************************************************
 ********************         Json validation functions           ********************
 *************************************************************************************/ 



DEFINE_PATCH_MACRO skipped_json_was_whole_buffer BEGIN
	PATCH_IF NOT skipped THEN BEGIN
		SET is_json = 0
	END ELSE BEGIN
		LPF skip_buffer_whitespace INT_VAR offset = offset RET offset srclength END
		SET is_json = offset == srclength
	END
END



/** Sets the %is_null% return variable to zero if the passed %json% argument is not a valid json `null`
  * (does not equal 'null'), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_null INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_null = is_json
		END
	END
	
	
	
/** Sets the %is_null% return variable to zero if the passed %json% argument is not a valid json `null`
  * (does not equal 'null'), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_null
	STR_VAR json = ~~
	RET is_null
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_null STR_VAR json = EVAL ~%json%~ RET is_null END
		END
	END
	
	
	
/** Sets the %is_boolean% return variable to zero if the passed %json% argument is not a valid 
  * json boolean value ('true' or 'false'), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_boolean INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_boolean = is_json
		END
	END
	
	
	
/** Sets the %is_boolean% return variable to zero if the passed %json% argument is not a valid 
  * json boolean value ('true' or 'false'), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_boolean
	STR_VAR json = ~~
	RET is_boolean
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_boolean STR_VAR json = EVAL ~%json%~ RET is_boolean END
		END
	END
	
	

/** Sets the %is_int% return variable to zero if tne passed %json% argument is not a valid 
  * json number (IS_AN_INT is not true for the trimmed string), or to a non-zero value otherwise.
  */
DEFINE_ACTION_FUNCTION is_json_number
	STR_VAR json = ~~
	RET is_int
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_number INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_int = is_json
		END
	END



/** Sets the %is_int% return variable to zero if the passed %json% argument is not a valid 
  * json number (IS_AN_INT is not true for the trimmed string), or to a non-zero value otherwise.
  */
DEFINE_PATCH_FUNCTION is_json_number
	STR_VAR json = ~~
	RET is_int
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_number STR_VAR json = EVAL ~%json%~ RET is_int END
		END
	END
	
	

/** Sets the %is_string% return variable to zero if the passed %json% argument is not a valid json string,
  * or to a non-zero value otherwise. The input %json% is trimmed of whitespace before validation.
  */
DEFINE_ACTION_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		OUTER_SET is_string = 1
		ACTION_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET is_string = 0
		END
	END
	
	

/** Sets the %is_string% return variable to zero if the passed %json% argument is not a valid json string,
  * or to a non-zero value otherwise. The input %json% is trimmed of whitespace before validation.
  */
DEFINE_PATCH_FUNCTION is_json_string
	STR_VAR json = ~~
	RET is_string
	BEGIN
		SET is_string = 1
		PATCH_IF ~%json%~ STRING_MATCHES_REGEXP ~^%WHITESPACE_RX%%JSON_STRING_RX%%WHITESPACE_RX%$~ THEN BEGIN
			SET is_string = 0
		END
	END
	
	

/** Sets the %is_array% return variable to zero if the passed %json% argument is not a valid json array,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_json_array
	STR_VAR json = ~~
	RET is_array
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_array INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_array = is_json
		END
	END
	
	

/** Sets the %is_array% return variable to zero if the passed %json% argument is not a valid json array,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_json_array
	STR_VAR json = ~~
	RET is_array
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_array STR_VAR json = EVAL ~%json%~ RET is_array END
		END
	END
	
	
	
/** Sets the %is_object% return variable to zero if the passed %json% argument is not a valid json object,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json_object INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			SET is_object = is_json
		END
	END



/** Sets the %is_object% return variable to zero if the passed %json% argument is not a valid json object,
  * or to a non-zero value otherwise. Any leading or trailing whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_json_object
	STR_VAR json = ~~
	RET is_object
	BEGIN
		INNER_ACTION BEGIN
			LAF is_json_object STR_VAR json = EVAL ~%json%~ RET is_object END
		END
	END
	
	
	
/** Sets the %is_object% return variable to zero if the passed %json% argument is not 
  * a correctly formatted Json, or to a non-zero value otherwise. Any leading or trailing 
  * whitespace is ignored.
  */
DEFINE_ACTION_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
		END
	END



/** Sets the %is_object% return variable to zero if the passed %json% argument is not 
  * a correctly formatted Json, or to a non-zero value otherwise. Any leading or trailing 
  * whitespace is ignored.
  */
DEFINE_PATCH_FUNCTION is_valid_json
	STR_VAR json = ~~
	RET is_json
	BEGIN
		INNER_ACTION BEGIN
			LAF is_valid_json STR_VAR json = EVAL ~%json%~ RET is_json END
		END
	END	
	
	
		
/** Fails if %json% is not a valid Json, no-op otherwise. */
DEFINE_ACTION_FUNCTION validate_json
	STR_VAR 
		json = ~~
		logprefix = ~~
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF skip_json INT_VAR offset = 0 RET offset skipped END
			LPM skipped_json_was_whole_buffer
			PATCH_IF NOT is_json THEN BEGIN
				PATCH_FAIL ~%logprefix%invalid json <<%json%>>.~
			END
		END
	END
	
	
	
/** Fails if %json% is not a valid Json, no-op otherwise. */	
DEFINE_PATCH_FUNCTION validate_json
	STR_VAR json = ~~ 
	BEGIN
		INNER_ACTION BEGIN
			LAF validate_json 
				STR_VAR logprefix = EVAL ~%logprefix%~ json = EVAL ~%json%~ 
			END
		END
	END


	
	
	

/*************************************************************************************
 ********************     Converting json to weidu variables      ********************
 *************************************************************************************/ 




DEFINE_PATCH_MACRO read_json_must_be_whole_buffer BEGIN
	PATCH_IF NOT offset THEN BEGIN
		LPF next_buffer_token 
			INT_VAR offset = 0
			STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
			RET json = token END		
		PATCH_FAIL ~Invalid json or unexpected data type: <<%json%>>.~
	END ELSE BEGIN
		LPF skip_buffer_whitespace INT_VAR offset = offset RET offset srclength END
		
		PATCH_IF offset != srclength THEN BEGIN
			LPF next_buffer_token 
				INT_VAR offset = offset
				STR_VAR non_token_chars = EVAL ~]}%WHITESPACE_CHARS%,;~
				RET json = token END		
			PATCH_FAIL ~Expected EOF but got: <<%json%>>~
		END
	END
END


	
DEFINE_ACTION_FUNCTION json_boolean_value
	STR_VAR json = ~~
	RET res 
	BEGIN
		ACTION_IF ~%json%~ STR_EQ ~true~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF ~%json%~ STR_EQ ~false~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE BEGIN
			FAIL ~Expected a Json Boolean but got: <<%json%>>.~
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_boolean_value
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_boolean_value STR_VAR json = EVAL ~%json%~ RET res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_boolean
	STR_VAR json = ~~
	RET res
	BEGIN
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%true%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET res = 1
		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%false%WHITESPACE_RX%$~ THEN BEGIN
			OUTER_SET res = 0
		END ELSE BEGIN
			FAIL ~Expected a Json Boolean but got: <<%json%>>.~
		END
	END
		
		
		
DEFINE_PATCH_FUNCTION json_to_boolean
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_to_boolean STR_VAR json = EVAL ~%json%~ RET res END
		END
	END



DEFINE_ACTION_FUNCTION json_number_value
	STR_VAR json = ~~
	RET res
	BEGIN 
		ACTION_IF IS_AN_INT ~%json%~ THEN BEGIN
			OUTER_SET res = ~%json%~ 
		END ELSE BEGIN
			FAIL ~json_number_value: not a number <<%json%>>~
//			OUTER_PATCH ~%json%~ BEGIN
//				LPF read_json_number INT_VAR offset = 0 RET res END
//			END
		END
	END

	
	
DEFINE_PATCH_FUNCTION json_number_value
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_number_value STR_VAR json = EVAL ~%json%~ RET res END
		END
	END



DEFINE_ACTION_FUNCTION json_to_int
	STR_VAR json = ~~
	RET res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_number INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_int
	STR_VAR json = ~~
	RET res 
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_number INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	

	
DEFINE_ACTION_FUNCTION json_string_value 
	STR_VAR json = ~~
	RET res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_PATCH_FUNCTION json_string_value
	STR_VAR json = ~~
	RET res 
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_string
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_string INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END

	

DEFINE_ACTION_FUNCTION json_value
	STR_VAR json = ~~
	RET res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_value INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_PATCH_FUNCTION json_value
	STR_VAR json = ~~
	RET res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_value INT_VAR offset = 0 RET offset res END
			LPM read_json_must_be_whole_buffer
		END
	END



DEFINE_ACTION_FUNCTION json_to_raw_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_to_raw_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_array
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_array INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END





	
DEFINE_ACTION_FUNCTION raw_json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION raw_json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_raw_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END


	
DEFINE_ACTION_FUNCTION json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res 
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	

DEFINE_PATCH_FUNCTION json_object_fields
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_object_fields INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION json_to_dict
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			LPF read_json_as_dict INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_to_dict
	STR_VAR json = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			LPF read_json_as_dict INT_VAR offset = 0 RET offset size RET_ARRAY res END
			LPM read_json_must_be_whole_buffer
		END
	END



/*************************************************************************************
 ********************    Extracting individual values from Json   ********************
 *************************************************************************************/ 



/** Returns the size (number of elements) of the given json array. */
DEFINE_ACTION_FUNCTION json_array_size
	STR_VAR json = ~~
	RET size
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			SET offset = 0
			LPF skip_json_array INT_VAR offset = 0 RET skipped = offset size END
			LPM skipped_json_was_whole_buffer
		END
	END
	
	

/** Returns the size (number of elements) of the given json array. */
DEFINE_PATCH_FUNCTION json_array_size
	STR_VAR json = ~~
	RET size
	BEGIN
		INNER_PATCH ~%json%~ BEGIN
			SET offset = 0
			LPF skip_json_array INT_VAR offset = 0 RET skipped = offset size END
			LPM skipped_json_was_whole_buffer
		END
	END



/** Returns the element at the specified index in the array. The element is returned as json. */	
DEFINE_ACTION_FUNCTION json_array_element
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN	
		ACTION_IF idx < 0 THEN BEGIN
			OUTER_TEXT_SPRINT res ~%default%~
		END ELSE BEGIN
			OUTER_PATCH ~%json%~ BEGIN
				LPF skip_buffer_whitespace INT_VAR offset = 0 RET offset next END
				
				PATCH_IF NOT ~%next%~ STR_EQ ~[~ THEN BEGIN
					PATCH_FAIL ~json_array_element: expected '[' but got '%next%' at #%offset% in json <<%json%>>.~
				END
				
			
				LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET start = offset next END
				SET skipped = 0
				
				WHILE idx >= 0 AND NOT (~%next%~ STR_EQ ~]~) BEGIN
					PATCH_IF skipped THEN BEGIN //not the first iteration
						PATCH_IF NOT ~%next%~ STR_EQ ~,~ THEN BEGIN
							PATCH_FAIL ~json_array_element: expected ',' but got '%next%' at #%offset% in json <<%json%>>.~
						END
						LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET start = offset END
					END						

					LPF skip_json INT_VAR offset = start RET end = offset skipped END
					
					PATCH_IF NOT skipped THEN BEGIN
						PATCH_FAIL ~json_array_element: invalid json element at #%start% in json <<%json%>>.~
					END
					LPF skip_buffer_whitespace INT_VAR offset = end RET offset next END
					SET idx -= 1
				END
				
				PATCH_IF idx < 0 THEN BEGIN
					READ_ASCII start res (end - start)
				END ELSE BEGIN
					TEXT_SPRINT res ~%default%~
				END
			END		
		END
	END
	
	
	
/** Returns the element at the specified index in the array. The element is returned as json. */	
DEFINE_PATCH_FUNCTION json_array_element
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_element 
				INT_VAR idx = idx 
				STR_VAR json = EVAL ~%json%~ default = EVAL ~%default%~
				RET res END
		END
	END
		
	

/** Returns the element at the specified index in the array. 
  * The json element is converted to a weidu variable before returning:
  *  - strings are unescaped and without the extra '"' chars;
  *  - numbers are returned verbatim (formatted as strings);
  *  - boolean values are converted to ~0~ or ~1~;
  *  - other elements can't be converted and result in a failure.
. */	
DEFINE_ACTION_FUNCTION json_array_at
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		ACTION_IF idx < 0 THEN BEGIN
			FAIL ~Index out of bounds: %idx% element of %json%~
		END
		LAF json_array_element INT_VAR idx = idx STR_VAR json = EVAL ~%json%~ RET element = res END
		ACTION_IF ~%element%~ STR_EQ ~~ THEN BEGIN
			FAIL ~Index out of bounds or invalid json: %idx% element of %json%~
		END
		LAF json_value STR_VAR json = EVAL ~%element%~ RET res END
	END
	
		
	
/** Returns the element at the specified index in the array. 
  * The json element is converted to a weidu variable before returning:
  *  - strings are unescaped and without the extra '"' chars;
  *  - numbers are returned verbatim (formatted as strings);
  *  - boolean values are converted to ~0~ or ~1~;
  *  - other elements can't be converted and result in a failure.
. */	
DEFINE_PATCH_FUNCTION json_array_at
	INT_VAR 
		/** Index of the required element. */
		idx = 0
	STR_VAR 
		/** Input array in the json format. */ 
		json = ~~ 
		/** Default value returned if index %idx% is out of range. */
		default = ~~
	RET 
		/** Required element as json or %default% if no such element exists. */
		res 
	BEGIN
		INNER_ACTION BEGIN
			LAF json_array_at INT_VAR idx = idx STR_VAR json = EVAL ~%json%~ RET res END
		END
	END


	
DEFINE_ACTION_FUNCTION json_raw_field	
	STR_VAR
		json = ~~
		field = ~~
		rawfield = ~~
		default = ~~
	RET	res
	BEGIN
		OUTER_PATCH ~%json%~ BEGIN
			PATCH_IF ~%rawfield%~ STR_EQ ~~ THEN BEGIN
				LPF json_string STR_VAR string = EVAL ~%field%~ RET rawfield = res END
			END

			LPF skip_buffer_whitespace INT_VAR offset = 0 RET offset next END
			
			PATCH_IF NOT ~%next%~ STR_EQ ~{~ THEN BEGIN
				PATCH_FAIL ~json_raw_field: expected '{' but got '%next%' at #%offset% in json <<%json%>>.~
			END
			
			LPF skip_buffer_whitespace INT_VAR offset = offset + 1 RET offset next END
			TEXT_SPRINT property ~~

			WHILE NOT (~%next%~ STR_EQ ~}~ OR ~%property%~ STR_EQ ~%rawfield%~) BEGIN
				PATCH_IF NOT ~%property%~ STR_EQ ~~ THEN BEGIN //not the first iteration
					PATCH_IF NOT ~%next%~ STR_EQ ~,~ THEN BEGIN
						PATCH_FAIL ~json_raw_field: expected ',' but got '%next%' at #%offset% in <<%json%>>.~
					END
					SET offset += 1
				END
				
				LPF read_raw_json_object_field 
					INT_VAR offset = offset 
					RET property = field res = value offset END
				LPF skip_buffer_whitespace INT_VAR offset = offset RET offset next END
			END
			
			PATCH_IF NOT ~%property%~ STR_EQ ~%rawfield%~ THEN BEGIN
				TEXT_SPRINT res ~%default%~
			END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION json_raw_field
	STR_VAR
		json = ~~
		rawfield = ~~
		field = ~~
		default = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_raw_field 
				STR_VAR 
					json = EVAL ~%json%~ 
					rawfield = EVAL ~%rawfield%~
					field = EVAL ~%field%~ 
					default = EVAL ~%default%~
				RET res END
		END
	END



DEFINE_ACTION_FUNCTION json_field
	STR_VAR
		json = ~~
		field = ~~
	RET res
	BEGIN
		LAF json_raw_field 
			STR_VAR json = EVAL ~%json%~ field = EVAL ~%field%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~json_field: no field named '%field%' in object '%json%'~
		END
		LAF json_value STR_VAR json = EVAL ~%res%~ RET res END
	END
	

	
DEFINE_PATCH_FUNCTION json_field	
	STR_VAR
		json = ~~
		field = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF json_field 
				STR_VAR json = EVAL ~%json%~ field = EVAL ~%field%~
				RET res END
		END
	END






DEFINE_ACTION_FUNCTION get_json
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		OUTER_TEXT_SPRINT res ~~
		
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%{~ THEN BEGIN //json object			
			LAF json_object_fields 
				STR_VAR json = EVAL ~%json%~ 
				RET size 
				RET_ARRAY fields = res END		
			
			ACTION_IF size THEN BEGIN
				OUTER_TEXT_SPRINT prefix ~%property%~
				OUTER_TEXT_SPRINT suffix ~~
				OUTER_SET reduced = 1
				//iterate over property prefixes of %property% in decreasing length in search for a matching property
				OUTER_WHILE reduced BEGIN 
					OUTER_TEXT_SPRINT value ~~
					//we search in a loop instead of using VARIABLE_IS_SET because it doesn't work
					//with dots and other special characters in key names.
					ACTION_PHP_EACH fields AS field => child BEGIN
						ACTION_IF ~%field%~ STR_EQ ~%prefix%~ THEN BEGIN
							OUTER_TEXT_SPRINT value ~%child%~
						END
					END
					ACTION_IF NOT ~%value%~ STR_EQ ~~ THEN BEGIN
						ACTION_CLEAR_ARRAY fields
						LAF get_json //continue recursion with the suffix as the property
							STR_VAR 
								json = EVAL ~%value%~ 
								property = EVAL ~%suffix%~
								type = EVAL ~%type%~
							RET res END
						OUTER_SET reduced = 0 //terminate the loop
					
					END ELSE BEGIN //check the next prefix property
						OUTER_SET reduced = 0
						//If %prefix% starts with '.' check for property without that leading dot
						OUTER_PATCH_SAVE name ~%prefix%~ BEGIN
							REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^\.~ ~~
						END
						ACTION_PHP_EACH fields AS field => child BEGIN
							ACTION_IF ~%field%~ STR_EQ ~%name%~ THEN BEGIN
								OUTER_SET reduced = 1
								OUTER_TEXT_SPRINT prefix ~%name%~
							END
						END
						//if %prefix% ends with ~[<idx>]~ move the indexing to the front of %suffix% 
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\[\([0-9]+\)\]$~ BEGIN
									TEXT_SPRINT suffix ~[%MATCH1%]%suffix%~
									SET reduced = 1
								END ~~
							END
						END
						//if %prefix% ends with ~.<property>~ move that simple property to the front of %suffix%
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\.\([^.]*\)$~ BEGIN
									TEXT_SPRINT suffix ~.%MATCH1%%suffix%~
									SET reduced = 1
								END ~~
							END
						END
						//if %prefix% is non-empty, check for a ~~ property next, moving %prefix% to %suffix%
						ACTION_IF NOT reduced AND NOT ~%prefix%~ STR_EQ ~~ THEN BEGIN //%property% is a simple property
							OUTER_TEXT_SPRINT suffix ~%prefix%%suffix%~
							OUTER_TEXT_SPRINT prefix ~~						
							OUTER_SET reduced = 1
						END
					END
				END

			END
			
			ACTION_IF ~%res%~ STR_EQ ~~ AND ~%property%~ STR_EQ ~~ THEN BEGIN
				LAM trim_json
				OUTER_TEXT_SPRINT res ~%json%~
			END
			
		END ELSE ACTION_IF ~%property%~ STR_EQ ~~ THEN BEGIN
			LAM trim_json
			OUTER_TEXT_SPRINT res ~%json%~

		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%\[~ THEN BEGIN //json array
			OUTER_PATCH_SAVE property ~%property%~ BEGIN
				REPLACE_EVALUATE CASE_SENSITIVE ~^\[\([0-9]+\)\]\(.*\)$~ BEGIN
					SET idx = ~%MATCH1%~
					LPF json_array_element
						INT_VAR idx = idx 
						STR_VAR json = EVAL ~%json%~ 
						RET elem = res END
						
					PATCH_IF NOT ~%elem%~ STR_EQ ~~ THEN BEGIN
						LPF get_json 
							STR_VAR json = EVAL ~%elem%~ property = EVAL ~%MATCH2%~	type = EVAL ~%type%~
							RET res END	
					END				
				END ~~
			END
		END  
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json	
	STR_VAR 
		json = ~~
		property = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END
	
	

DEFINE_ACTION_FUNCTION has_property
	STR_VAR
		json = ~~
		property = ~~
	RET exists
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res END
		OUTER_SET exists = NOT ~%res%~ STR_EQ ~~
	END
	
	
	
DEFINE_PATCH_FUNCTION has_property				
	STR_VAR
		json = ~~
		property = ~~
	RET exists
	BEGIN
		INNER_ACTION BEGIN
			LAF has_property 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET exists END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION get_json_value 
	STR_VAR
		json = ~~
		property = ~~
	RET	
		res
		exists
	BEGIN
		LAF get_json
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			OUTER_SET exists = 0
		END ELSE BEGIN
			OUTER_SET exists = 1
			LAF json_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
		
		
		
DEFINE_PATCH_FUNCTION get_json_value 	
	STR_VAR
		json = ~~
		property = ~~
	RET
		res
		exists
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_value 
				STR_VAR 
					json = EVAL ~%json%~ 
					property = EVAL ~%property%~
				RET res exists END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_boolean
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No boolean property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_boolean_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_boolean
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_boolean
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_int
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res exists END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No number property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_int_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_int
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF get_json_int 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END
	
	
		
DEFINE_ACTION_FUNCTION get_json_string
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		LAF get_json 
			STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~ 
			RET res END
		ACTION_IF ~%res%~ STR_EQ ~~ THEN BEGIN
			FAIL ~No string property "%property%" in json '%json%'.~
		END ELSE BEGIN
			LAF json_string_value STR_VAR json = EVAL ~%res%~ RET res END
		END
	END
	
	
	
DEFINE_PATCH_FUNCTION get_json_string
	STR_VAR 
		json = ~~
		property = ~~
	RET
		res
	BEGIN
		INNER_ACTION BEGIN	
			LAF get_json_string 
				STR_VAR json = EVAL ~%json%~ property = EVAL ~%property%~
				RET res END
		END
	END






/*************************************************************************************
 ********************        Json modification functions          ********************
 *************************************************************************************/ 



/** Modifies the content of a json array given as a string around a given index. 
  * Separate arguments result in different type of modifications; providing multiple is possible.
  * Leaving the default value (~~) means that type of modification is not performed.
  * Allowed operations, and the order in which they are performed are as follows:
  *  - delete = <number>:  delete that many elements from the array, starting with index %at%;
  *  - set = <json>:       update the %at%-th element of the array to the given value
  *  - insert = <json>:    insert the new element at index %at%, pushing all items from that index 
  *                        further back (so the index of current item at %at% will be %at%+1 and so on).
  *  - insertall=<jarray>: insert all elements of the given array into the given array, pushing all
  *                        items currently at index %at% and above n slots further, where n is the number
  *                        of elements in the array.
  */
DEFINE_ACTION_FUNCTION update_json_array
	INT_VAR 
		/** Index in the modified array at which the change is made. Must be `0 <= at < size`
		  * (where size is the size of the array) for set and delete operations, 
		  * can be equal to size for insert/insertall. */
		at = 0
		/** Number of elements to delete from the array starting with index %at%. */
		delete = 0
	STR_VAR 
		/** The modified array in the Json format. */
		json = ~~
		/** Exchange the element at the given index for this one - must be valid json. */
		set = ~~
		/** Insert a new element to the array at the given index. Current element and all following are
		  * pushed up by 1. Must be valid json. */
		insert = ~~
		/** List of elements to insert at the given index in the json array format. All elements in
		  * the modified array from index %at% are pushed up to make space. */
		insertall = ~~
	RET 
		/** The array after the modification(s) in the json format. */
		res
	BEGIN		
		LAF json_to_raw_array
			STR_VAR json = EVAL ~%json%~ 
			RET size 
			RET_ARRAY array = res END
		
		ACTION_IF at < 0 OR at > size THEN BEGIN
			FAIL ~update_json_array: index %at% out of range <0..%size%>~
		END
		
		ACTION_IF delete > 0 OR NOT ~%insert%~ STR_EQ ~~ OR NOT ~%insertall%~ STR_EQ ~~ THEN BEGIN
			OUTER_FOR (i=0; i < at; ++i) BEGIN
				OUTER_TEXT_SPRINT $result(~%i%~) $array(~%i%~)
			END
			
			OUTER_SET i = at
			OUTER_SET j = at
			ACTION_IF delete > 0 THEN BEGIN
				OUTER_SET j += delete
			END	
			
			ACTION_IF NOT ~%insert%~ STR_EQ ~~ THEN BEGIN
				LAF validate_json STR_VAR
					logprefix = ~update_json_array insert: ~
					json = EVAL ~%insert%~
				END				
				OUTER_TEXT_SPRINT $result(~%i%~) ~%insert%~
				OUTER_SET i += 1
			END
			
			ACTION_IF NOT ~%insertall%~ STR_EQ ~~ THEN BEGIN
				LAF json_to_raw_array
					STR_VAR json = EVAL ~%insertall%~ 
					RET count = size RET_ARRAY elems = res END
				OUTER_FOR (k=0; k<count; ++k) BEGIN
					OUTER_TEXT_SPRINT $result(~%i%~) $elems(~%k%~)
					OUTER_SET i += 1
				END
			END
			
			ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				ACTION_IF j >= size THEN BEGIN
					FAIL ~update_json_array: set index %at% out of range.~
				END
				LAF validate_json STR_VAR
					logprefix = ~update_json_array set: ~
					json = EVAL ~%set%~
				END
				
				OUTER_TEXT_SPRINT $result(~%i%~) ~%set%~
				OUTER_SET j += 1
				OUTER_SET i += 1
			END

			OUTER_WHILE j < size BEGIN
				OUTER_TEXT_SPRINT $result(~%i%~) $array(~%j%~)
				OUTER_SET j += 1
				OUTER_SET i += 1
			END
			
			LAF concat 
				INT_VAR size = i
				STR_VAR arrayvar = ~result~ prefix = ~[~ separator = ~, ~ suffix = ~]~
				RET res END
			
		END ELSE ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
			ACTION_IF at < 0 OR at >= size THEN BEGIN
				FAIL ~update_json_array: index %at% out of range <0..%size%)~
			END
			LAF validate_json STR_VAR
				logprefix = ~update_json_array set: ~
				json = EVAL ~%set%~
			END
			
			OUTER_TEXT_SPRINT $array(~%at%~) ~%set%~
			
			LAF concat
				STR_VAR arrayvar = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
				RET res END
		
		END	ELSE BEGIN
			FAIL ~update_json_array: delete, set, insert or insertall argument required~
		END
	END
	
	
	
/** Modifies the content of a json array given as a string around a given index. 
  * Separate arguments result in different type of modifications; providing multiple is possible.
  * Leaving the default value (~~) means that type of modification is not performed.
  * Allowed operations, and the order in which they are performed are as follows:
  *  - delete = <number>:  delete that many elements from the array, starting with index %at%;
  *  - set = <json>:       update the %at%-th element of the array to the given value
  *  - insert = <json>:    insert the new element at index %at%, pushing all items from that index 
  *                        further back (so the index of current item at %at% will be %at%+1 and so on).
  *  - insertall=<jarray>: insert all elements of the given array into the given array, pushing all
  *                        items currently at index %at% and above n slots further, where n is the number
  *                        of elements in the array.
  */
DEFINE_PATCH_FUNCTION update_json_array
	INT_VAR 
		/** Index in the modified array at which the change is made. Must be `0 <= at < size`
		  * (where size is the size of the array) for set and delete operations, 
		  * can be equal to size for insert/insertall. */
		at = 0
		/** Number of elements to delete from the array starting with index %at%. */
		delete = 0
	STR_VAR 
		/** The modified array in the Json format. */
		json = ~~
		/** Exchange the element at the given index for this one - must be valid json. */
		set = ~~
		/** Insert a new element to the array at the given index. Current element and all following are
		  * pushed up by 1. Must be valid json. */
		insert = ~~
		/** List of elements to insert at the given index in the json array format. All elements in
		  * the modified array from index %at% are pushed up to make space. */
		insertall = ~~
	RET 
		/** The array after the modification(s) in the json format. */
		res
	BEGIN
		INNER_ACTION BEGIN
			LAF update_json_array 
				INT_VAR at = at delete = delete
				STR_VAR 
					json = EVAL ~%json%~ 
					set = EVAL ~%set%~
					insert = EVAL ~%insert%~
					insertall = EVAL ~%insertall%~
				RET res END
		END
	END
		


/** Updates a json object given as a string. The update may consist of any of the following operations:
  *  - adding all fields from another object, overwriting previous values;
  *  - deleting a single field;
  *  - setting the value of a single field, adding that field if not previously present.
  * If more than one operation is requested, they are executed in that order; only one of each is possible
  * however. At least one of %merge%, %delete%, %set% input variables should be specified; ommiting any
  * means the corresponding operation will not be performed.
  */
DEFINE_ACTION_FUNCTION update_json_object
	STR_VAR
		/** Updated object given as a valid json string. */
		json = ~~
		/** Another valid json object given as a string. */
		merge = ~~
		/** Name of the field (without surrounding '"') to delete. */
		delete = ~~
		/** Name of the field (without surrounding '"') to update. */
		set = ~~
		/** New value for the updated field specified by %set%. Must be valid json if %set% is provided. */
		value = ~~
	RET 
		/** The object with the changes applied as a json string. */
		res
	BEGIN		
		LAF raw_json_object_fields
			STR_VAR json = EVAL ~%json%~
			RET size
			RET_ARRAY array = res END
		ACTION_IF NOT size THEN BEGIN		
			ACTION_IF NOT ~%merge%~ STR_EQ ~~ THEN BEGIN
				LAF update_json_object 
					STR_VAR
						json = EVAL ~%merge%~
						delete = EVAL ~%delete%~
						set = EVAL ~%set%~
						value = EVAL ~%value%~
					RET res END
					
			END ELSE ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				LAF json_string STR_VAR string = EVAL ~%set%~ RET key = res END
				
				LAF validate_json STR_VAR 
					logprefix = ~update_json_object set "%set%" value: ~ 
					json = EVAL ~%value%~ 
				END
				OUTER_TEXT_SPRINT res ~{%key%: %value%}~
			END
		
		END ELSE BEGIN
			OUTER_SET nonempty = size
			LAF json_string STR_VAR string = EVAL ~%delete%~ RET deletekey = res END
			
			ACTION_IF NOT ~%delete%~ STR_EQ ~~ 
			      AND VARIABLE_IS_SET $array(~%deletekey%~)
				  AND NOT ~%delete%~ STR_EQ ~%set%~ THEN BEGIN
						
				ACTION_PHP_EACH array AS key => value BEGIN
					ACTION_IF NOT ~%deletekey%~ STR_EQ ~%key%~ THEN BEGIN
						OUTER_TEXT_SPRINT $newarray(~%key%~) ~%value%~
					END
				END
				OUTER_SET nonempty -= 1
				OUTER_TEXT_SPRINT fields ~newarray~
			END ELSE BEGIN
				OUTER_TEXT_SPRINT deletekey ~"~ //invalid json, ergo will never equal
				OUTER_TEXT_SPRINT fields ~array~
			END
			
			ACTION_IF NOT ~%merge%~ STR_EQ ~~ THEN BEGIN
				LAF raw_json_object_fields 
					STR_VAR json = EVAL ~%merge%~ 
					RET count = size 
					RET_ARRAY merged = res END

				ACTION_IF count THEN BEGIN					
					ACTION_PHP_EACH merged AS key => value BEGIN
						ACTION_IF NOT ~%deletekey%~ STR_EQ ~%key%~ THEN BEGIN
							OUTER_TEXT_SPRINT $~%fields%~(~%key%~) ~%value%~
							OUTER_SET nonempty = 1
						END
					END
				END
			END
			
			ACTION_IF NOT ~%set%~ STR_EQ ~~ THEN BEGIN
				LAF validate_json STR_VAR 
					logprefix = ~update_json_object set='%set%' value: ~
					json = EVAL ~%json%~ 
				END
				
				LAF json_string STR_VAR string = EVAL ~%set%~ RET setkey = res END
				
				OUTER_TEXT_SPRINT $~%fields%~(~%setkey%~) ~%value%~
				OUTER_SET nonempty = 1
			END
			
			ACTION_IF nonempty THEN BEGIN
				LAF json_object STR_VAR rawfields = EVAL ~%fields%~ RET res END
			END ELSE BEGIN
				OUTER_TEXT_SPRINT res ~{}~
			END
			
		END
	END
	


/** Updates a json object given as a string. The update may consist of any of the following operations:
  *  - adding all fields from another object, overwriting previous values;
  *  - deleting a single field;
  *  - setting the value of a single field, adding that field if not previously present.
  * If more than one operation is requested, they are executed in that order; only one of each is possible
  * however. At least one of %merge%, %delete%, %set% input variables should be specified; ommiting any
  * means the corresponding operation will not be performed.
  */
DEFINE_PATCH_FUNCTION update_json_object
	STR_VAR
		/** Updated object given as a valid json string. */
		json = ~~
		/** Another valid json object given as a string. */
		merge = ~~
		/** Name of the field (without surrounding '"') to delete. */
		delete = ~~
		/** Name of the field (without surrounding '"') to update. */
		set = ~~
		/** New value for the updated field specified by %set%. Must be valid json if %set% is provided. */
		value = ~~
	RET 
		/** The object with the changes applied as a json string. */
		res
	BEGIN		
		INNER_ACTION BEGIN
			LAF update_json_object 
				STR_VAR 
					json = EVAL ~%json%~ 
					merge = EVAL ~%merge%~
					delete = EVAL ~%delete%~
					set = EVAL ~%set%~
					value = EVAL ~%value%~
				RET res END
		END
	END
	
	
	
	

		



/*		
DEFINE_ACTION_FUNCTION set_json
	STR_VAR
		json = ~~
		property = ~~
		value = ~~
	RET
		res
	BEGIN
		//TODO
		OUTER_TEXT_SPRINT res ~~
		
		ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%{~ THEN BEGIN //json object			
			LAF json_object_fields 
				STR_VAR json = EVAL ~%json%~ 
				RET size 
				RET_ARRAY fields = res END		
			
			ACTION_IF size THEN BEGIN
				OUTER_TEXT_SPRINT prefix ~%property%~
				OUTER_TEXT_SPRINT suffix ~~
				OUTER_SET reduced = 1
				//iterate over property prefixes of %property% in decreasing length in search for a matching property
				OUTER_WHILE reduced BEGIN 
					OUTER_TEXT_SPRINT value ~~
					//we search in a loop instead of using VARIABLE_IS_SET because it doesn't work
					//with dots and other special characters in key names.
					ACTION_PHP_EACH fields AS field => child BEGIN
						ACTION_IF ~%field%~ STR_EQ ~%prefix%~ THEN BEGIN
							OUTER_TEXT_SPRINT value ~%child%~
						END
					END
					ACTION_IF NOT ~%value%~ STR_EQ ~~ THEN BEGIN
						ACTION_CLEAR_ARRAY fields
						LAF get_json //continue recursion with the suffix as the property
							STR_VAR 
								json = EVAL ~%value%~ 
								property = EVAL ~%suffix%~
								type = EVAL ~%type%~
							RET res END
						OUTER_SET reduced = 0 //terminate the loop
					
					END ELSE BEGIN //check the next prefix property
						OUTER_SET reduced = 0
						//If %prefix% starts with '.' check for property without that leading dot
						OUTER_PATCH_SAVE name ~%prefix%~ BEGIN
							REPLACE_TEXTUALLY CASE_SENSITIVE EVALUATE_REGEXP ~^\.~ ~~
						END
						ACTION_PHP_EACH fields AS field => child BEGIN
							ACTION_IF ~%field%~ STR_EQ ~%name%~ THEN BEGIN
								OUTER_SET reduced = 1
								OUTER_TEXT_SPRINT prefix ~%name%~
							END
						END
						//if %prefix% ends with ~[<idx>]~ move the indexing to the front of %suffix% 
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\[\([0-9]+\)\]$~ BEGIN
									TEXT_SPRINT suffix ~[%MATCH1%]%suffix%~
									SET reduced = 1
								END ~~
							END
						END
						//if %prefix% ends with ~.<property>~ move that simple property to the front of %suffix%
						ACTION_IF NOT reduced THEN BEGIN
							OUTER_PATCH_SAVE prefix ~%prefix%~ BEGIN
								REPLACE_EVALUATE CASE_SENSITIVE ~\.\([^.]*\)$~ BEGIN
									TEXT_SPRINT suffix ~.%MATCH1%%suffix%~
									SET reduced = 1
								END ~~
							END
						END
						//if %prefix% is non-empty, check for a ~~ property next, moving %prefix% to %suffix%
						ACTION_IF NOT reduced AND NOT ~%prefix%~ STR_EQ ~~ THEN BEGIN //%property% is a simple property
							OUTER_TEXT_SPRINT suffix ~%prefix%%suffix%~
							OUTER_TEXT_SPRINT prefix ~~						
							OUTER_SET reduced = 1
						END
					END
				END

			END
			
			ACTION_IF ~%res%~ STR_EQ ~~ AND ~%property%~ STR_EQ ~~ THEN BEGIN
				LAM trim_json
				OUTER_TEXT_SPRINT res ~%json%~
			END
			
		END ELSE ACTION_IF ~%property%~ STR_EQ ~~ THEN BEGIN
			LAM trim_json
			OUTER_TEXT_SPRINT res ~%json%~

		END ELSE ACTION_IF NOT ~%json%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%\[~ THEN BEGIN //json array
			OUTER_PATCH_SAVE property ~%property%~ BEGIN
				REPLACE_EVALUATE CASE_SENSITIVE ~^\[\([0-9]+\)\]\(.*\)$~ BEGIN
					SET idx = ~%MATCH1%~
					LPF json_array_element
						INT_VAR idx = idx 
						STR_VAR json = EVAL ~%json%~ 
						RET elem = res END
						
					PATCH_IF NOT ~%elem%~ STR_EQ ~~ THEN BEGIN
						LPF get_json 
							STR_VAR 
								json = EVAL ~%elem%~ 
								property = EVAL ~%MATCH2%~
								type = EVAL ~%type%~
							RET res END	
					END				
				END ~~
			END
		END  
	END
	
	
	
DEFINE_PATCH_FUNCTION set_json	
	STR_VAR 
		json = ~~
		property = ~~
		value = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF set_json 
				STR_VAR 
					json = EVAL ~%json%~ 
					property = EVAL ~%property%~
					value = EVAL ~%property%~
				RET res END
		END
	END
*/













DEFINE_ACTION_FUNCTION read_json_file
	STR_VAR file = ~~
	RET json
	BEGIN
		OUTER_SET size = SIZE_OF_FILE ~%file%~
		
		COPY ~%file%~ ~%MOD_FOLDER%~ //just read
			READ_ASCII 0 json (%size%)  
		BUT_ONLY_IF_IT_CHANGES
		
		LAF is_valid_json STR_VAR json = EVAL ~%json%~ RET is_json END
		ACTION_IF NOT is_json THEN BEGIN
			FAIL ~File %file% does not contain valid Json data: 
%json%~
		END
	END



DEFINE_ACTION_FUNCTION read_2da_as_json_array
	STR_VAR 
		file = ~~
		comment = ~~
	RET size
	RET_ARRAY res
	BEGIN
		LAF regexp_escape STR_VAR str = EVAL ~%comment%~ RET comment_rx = regexp END
		
		COPY ~%file%~ ~%MOD_FOLDER%/JSON4WEIDU-DELETEME.2da~
			SET size = 0 - 1
			REPLACE_EVALUATE CASE_SENSITIVE ~^.+$~ BEGIN
				PATCH_IF (comment STR_EQ ~~ 
				         OR ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%comment_rx%~)
					 AND ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%$~	 
				THEN BEGIN
					PATCH_IF size < 0 THEN BEGIN
						LPF split_string 
							INT_VAR nonempty = 1
							STR_VAR string = EVAL ~%MATCH0%~ separators = ~	 ~
							RET columns = size
							RET_ARRAY fields = res END
					END ELSE BEGIN
						LPF split_string
							INT_VAR nonempty = 1
							STR_VAR string = EVAL ~%MATCH0%~ separators = ~	 ~
							RET count = size
							RET_ARRAY values = res END
						PATCH_IF count > columns THEN BEGIN
							PATCH_FAIL ~data row has more columns than header (%columns%) in file %file%: 
%MATCH0%~
						END
						
						CLEAR_ARRAY dict
						PHP_EACH values AS col => value BEGIN
							TEXT_SPRINT name $fields(~%col%~)
							TEXT_SPRINT $dict(~%name%~) ~%value%~
						END
						LPF json_object STR_VAR dict = ~dict~ RET elem = res END
						TEXT_SPRINT $res(~%size%~) ~%elem%~
					END
					SET size += 1
				END
			END ~%MATCH0%~	
			
			PATCH_IF size <= 0 THEN BEGIN
				SET size = 0
				TEXT_SPRINT $res(~0~) ~~
			END
		BUT_ONLY_IF_IT_CHANGES
	END

	

DEFINE_PATCH_FUNCTION read_2da_as_json_array
	STR_VAR
		file = ~~
		comment = ~~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_2da_as_json_array
				STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
				RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION read_2da_as_json
	STR_VAR
		file = ~~
		comment = ~~
	RET res
	BEGIN
		LAF read_2da_as_json_array
			STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
			RET size RET_ARRAY array = res END
		LAF concat
			INT_VAR size = size
			STR_VAR arrayvar = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
			RET res END			
	END
	
	
	
DEFINE_PATCH_FUNCTION read_2da_as_json
	STR_VAR
		file = ~~
		comment = ~~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_2da_as_json 
				STR_VAR file = EVAL ~%file%~ comment = EVAL ~%comment%~
				RET res END
		END
	END
			
		




DEFINE_ACTION_FUNCTION read_csv_as_json_array
	STR_VAR 
		file = ~~
		comment = ~~
		separators = ~,~
	RET size
	RET_ARRAY res
	BEGIN
		LAF regexp_escape STR_VAR str = EVAL ~%comment%~ RET comment_rx = regexp END
		
		ACTION_MATCH STRING_LENGTH ~%separators%~ WITH
			0 BEGIN
				OUTER_TEXT_SPRINT separator_rx ~%WHITESPACE_RX%~
			END
			1 WHEN separators STRING_CONTAINS_REGEXP ~[?\.*+]~ BEGIN
				OUTER_TEXT_SPRINT separator_rx ~\%separators%~
			END
			1 BEGIN
				OUTER_TEXT_SPRINT separator_rx ~%separators%~
			END
			DEFAULT
				OUTER_TEXT_SPRINT separator_rx ~[%separators%]~
		END
		
		COPY ~%file%~ ~%MOD_FOLDER%/JSON4WEIDU-DELETEME.csv~
			SET size = 0 - 1
			REPLACE_EVALUATE CASE_SENSITIVE ~^.+$~ BEGIN //for non-empty lines
				PATCH_IF (comment STR_EQ ~~ //skip whitespace and comment lines
				         OR ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%comment_rx%~)
					 AND ~%MATCH0%~ STRING_CONTAINS_REGEXP ~^%WHITESPACE_RX%$~	 
				THEN BEGIN
					PATCH_IF size < 0 THEN BEGIN
						//first line, treat it as a header with names for the columns
						LPF split_string 
							INT_VAR nonempty = 1
							STR_VAR 
								string = EVAL ~%MATCH0%~ 
								regexp = EVAL ~%separator_rx%~
							RET columns = size
							RET_ARRAY fields = res END
						PHP_EACH values AS col => name BEGIN
							LPF trim_string STR_VAR string = EVAL ~%name%~ RET name = res END
							TEXT_SPRINT $columns(~%col%~) ~%name%~
						END
						
					END ELSE BEGIN
						LPF split_string
							INT_VAR nonempty = 1
							STR_VAR 
								string = EVAL ~%MATCH0%~ 
								regexp = EVAL ~%separator_rx%~
							RET count = size
							RET_ARRAY values = res END
						PATCH_IF count > columns THEN BEGIN
							PATCH_FAIL ~data row has more columns than header (%columns%) in file %file%: 
%MATCH0%~
						END
						
						CLEAR_ARRAY dict
						PHP_EACH values AS col => value BEGIN
							LPF trim_string STR_VAR string = EVAL ~%value%~ RET value = res END
							PATCH_IF NOT value STR_EQ ~~ THEN BEGIN
								TEXT_SPRINT name $fields(~%col%~)
								TEXT_SPRINT $dict(~%name%~) ~%value%~
							END
						END
						
						LPF json_object STR_VAR dict = ~dict~ RET elem = res END
						TEXT_SPRINT $res(~%size%~) ~%elem%~
					END
					SET size += 1
				END
			END ~%MATCH0%~	
			
			PATCH_IF size <= 0 THEN BEGIN
				SET size = 0
				TEXT_SPRINT $res(~0~) ~~
			END
		BUT_ONLY_IF_IT_CHANGES
	END

	

DEFINE_PATCH_FUNCTION read_csv_as_json_array
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET size
	RET_ARRAY res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_csv_as_json_array
				STR_VAR 
					file = EVAL ~%file%~ 
					comment = EVAL ~%comment%~
					separators = EVAL ~%separators%~
				RET size RET_ARRAY res END
		END
	END
	
	
	
DEFINE_ACTION_FUNCTION read_csv_as_json
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET res
	BEGIN
		LAF read_csv_as_json_array
			STR_VAR 
				file = EVAL ~%file%~ 
				comment = EVAL ~%comment%~
				separators = EVAL ~%separators%~
			RET size RET_ARRAY array = res END
		LAF concat
			INT_VAR size = size
			STR_VAR arrayvar = ~array~ prefix = ~[~ separator = ~, ~ suffix = ~]~
			RET res END			
	END
	
	
	
DEFINE_PATCH_FUNCTION read_csv_as_json
	STR_VAR
		file = ~~
		comment = ~~
		separators = ~,~
	RET res
	BEGIN
		INNER_ACTION BEGIN
			LAF read_csv_as_json 
				STR_VAR 
					file = EVAL ~%file%~ 
					comment = EVAL ~%comment%~
					separators = EVAL ~%separators%~
				RET res END
		END
	END		





END //JSON4WEIDU	
			